<!DOCTYPE html><html lang="zh-Hans"><head>
  <meta charset="utf-8">
  <title>组件测试工具 Component Harnesses - Angular Material 组件库</title>
  <link rel="canonical" href="https://material.angular.io">
  <base href="/">

  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="translucent">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="theme-color" content="#3F50B5">
  <meta name="description" content="UI component infrastructure and Material Design components for mobile and desktop Angular web applications.">
  <meta name="keywords" content="angular, material design, material, angular material, web, ui, components, responsive, accessibility, typescript, css, mobile web, open source">
  <meta name="author" content="Angular Components Team">

  <!--Twitter card metadata-->
  <meta name="twitter:card" content="summary">
  <meta name="twitter:site" content="@Angular">
  <meta name="twitter:creator" content="@Angular">
  <meta name="twitter:title" content="Angular Material">
  <meta name="twitter:description" content="UI component infrastructure and Material Design components for Angular web applications.">
  <meta name="twitter:image" content="https://material.angular.io/assets/img/site-preview.png">

  <!--Facebook Open Graph-->
  <meta property="og:url" content="https://material.angular.io/">
  <meta property="og:type" content="website">
  <meta property="og:title" content="Angular Material">
  <meta property="og:site_name" content="Angular Material">
  <meta property="og:locale" content="en_US">
  <meta property="og:description" content="UI component infrastructure and Material Design components for Angular web applications.">
  <meta property="og:image" content="https://material.angular.io/assets/img/site-preview.png">
  <meta property="og:image:secure_url" content="https://material.angular.io/assets/img/site-preview.png">
  <meta property="og:image:type" content="image/png">
  <meta property="og:image:width" content="1339">
  <meta property="og:image:height" content="943">

  <link rel="apple-touch-icon" sizes="180x180" href="assets/img/favicons/apple-touch-icon.png?v=8.2.3">
  <link rel="icon" type="image/png" sizes="32x32" href="assets/img/favicons/favicon-32x32.png?v=8.2.3">
  <link rel="icon" type="image/png" sizes="16x16" href="assets/img/favicons/favicon-16x16.png?v=8.2.3">
  <link rel="manifest" href="assets/img/favicons/manifest.json?v=8.2.3">
  <link rel="mask-icon" href="assets/img/favicons/safari-pinned-tab.svg?v=8.2.3" color="#3f51b5">
  <link rel="shortcut icon" href="assets/img/favicons/favicon.ico?v=8.2.3">
  <meta name="msapplication-TileColor" content="#3f51b5">
  <meta name="msapplication-config" content="assets/img/favicons/browserconfig.xml?v=8.2.3">
  <meta name="theme-color" content="#3f51b5">

  <link href="assets/translator/css/material-icons.css" rel="stylesheet" media="all" onload="this.media='all'"><noscript><link rel="stylesheet" href="assets/translator/css/material-icons.css"></noscript>
  <link href="assets/translator/css/material-roboto-mono.css" rel="stylesheet" media="all" onload="this.media='all'"><noscript><link rel="stylesheet" href="assets/translator/css/material-roboto-mono.css"></noscript>
  <link href="assets/translator/css/translator.css" rel="stylesheet" media="all" onload="this.media='all'"><noscript><link rel="stylesheet" href="assets/translator/css/translator.css"></noscript>

  <!--Structured Data-->
  <script async="" src="https://www.google-analytics.com/analytics.js"></script><script type="application/ld+json">
    {
      "@context": "http://schema.org",
      "@type": "WebApplication",
      "name": "Angular Material",
      "description": "UI component infrastructure and Material Design components for Angular web applications.",
      "url": "https://material.angular.io",
      "image": "https://material.angular.io/assets/img/site-preview.png",
      "screenshot": "https://material.angular.io/assets/img/site-preview.png",
      "applicationCategory": "Software Documentation",
      "operatingSystem": "Android, Chrome OS, iOS, iPadOS, macOS, OS X, Linux, Windows",
      "author": {
        "@type": "Organization",
        "name": "Angular",
        "description": "Angular is a platform for building mobile and desktop web applications. Join the community of millions of developers who build compelling user interfaces with Angular.",
        "url": "https://angular.io",
        "logo": "https://angular.io/assets/images/logos/angular/angular.svg"
      }
    }
  </script>
<style>body,html{height:100vh;}body{font-family:Roboto,Helvetica Neue Light,Helvetica Neue,Helvetica,Arial,Lucida Grande,sans-serif;margin:0;}.docs-app-background{background:#fafafa;}</style><link rel="stylesheet" href="styles.36ba723dd229ee46967f.css" media="all" onload="this.media='all'"><noscript><link rel="stylesheet" href="styles.36ba723dd229ee46967f.css"></noscript><style>material-docs-app{display:flex;flex-direction:column;height:100vh}app-navbar{position:fixed;top:0;left:0;right:0;z-index:2}material-docs-app>app-component-sidenav{flex:1}material-docs-app>router-outlet+.main-content,material-docs-app>router-outlet+app-component-sidenav{margin-top:56px;overflow-y:auto;-webkit-overflow-scrolling:touch}@media (max-width:720px){material-docs-app>router-outlet+.main-content,material-docs-app>router-outlet+app-component-sidenav{margin-top:92px;overflow-y:visible}}</style><style>.docs-navbar-header[_ngcontent-material-docs-c46]{display:flex;flex-wrap:wrap;align-items:center;padding:8px 16px}.docs-navbar-header[_ngcontent-material-docs-c46] > .mat-button[_ngcontent-material-docs-c46]:last-child{margin-left:auto}.flex-spacer[_ngcontent-material-docs-c46]{flex-grow:1}.docs-angular-logo[_ngcontent-material-docs-c46]{height:26px;margin:0 4px 3px 0;vertical-align:middle}.docs-github-logo[_ngcontent-material-docs-c46]{height:21px;margin:0 7px 2px 0;vertical-align:middle}.docs-navbar-link[_ngcontent-material-docs-c46]{text-decoration:inherit;flex:1}.docs-navbar[_ngcontent-material-docs-c46], .docs-navbar-show-small[_ngcontent-material-docs-c46]{display:none}.skip-link-wrapper[_ngcontent-material-docs-c46]{position:absolute;top:10px;left:50%;transform:translateX(-50%);border-radius:5px}@media (max-width:720px){.docs-navbar-hide-small[_ngcontent-material-docs-c46]{display:none}.docs-navbar-show-small[_ngcontent-material-docs-c46]{display:block}.docs-navbar[_ngcontent-material-docs-c46]{display:flex}.docs-navbar--github-logo[_ngcontent-material-docs-c46]{margin:0}}theme-picker[_ngcontent-material-docs-c46]{display:none}@media (min-width:328px){theme-picker[_ngcontent-material-docs-c46]{display:block}}</style><style>.mat-button .mat-button-focus-overlay,.mat-icon-button .mat-button-focus-overlay{opacity:0}.mat-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay,.mat-stroked-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay{opacity:.04}@media(hover: none){.mat-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay,.mat-stroked-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay{opacity:0}}.mat-button,.mat-icon-button,.mat-stroked-button,.mat-flat-button{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible}.mat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner{border:0}.mat-button.mat-button-disabled,.mat-icon-button.mat-button-disabled,.mat-stroked-button.mat-button-disabled,.mat-flat-button.mat-button-disabled{cursor:default}.mat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-button.cdk-program-focused .mat-button-focus-overlay,.mat-icon-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-icon-button.cdk-program-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-program-focused .mat-button-focus-overlay,.mat-flat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-flat-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner{border:0}.mat-raised-button{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1)}.mat-raised-button::-moz-focus-inner{border:0}.mat-raised-button.mat-button-disabled{cursor:default}.mat-raised-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-raised-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-raised-button::-moz-focus-inner{border:0}._mat-animation-noopable.mat-raised-button{transition:none;animation:none}.mat-stroked-button{border:1px solid currentColor;padding:0 15px;line-height:34px}.mat-stroked-button .mat-button-ripple.mat-ripple,.mat-stroked-button .mat-button-focus-overlay{top:-1px;left:-1px;right:-1px;bottom:-1px}.mat-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);min-width:0;border-radius:50%;width:56px;height:56px;padding:0;flex-shrink:0}.mat-fab::-moz-focus-inner{border:0}.mat-fab.mat-button-disabled{cursor:default}.mat-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-fab::-moz-focus-inner{border:0}._mat-animation-noopable.mat-fab{transition:none;animation:none}.mat-fab .mat-button-wrapper{padding:16px 0;display:inline-block;line-height:24px}.mat-mini-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);min-width:0;border-radius:50%;width:40px;height:40px;padding:0;flex-shrink:0}.mat-mini-fab::-moz-focus-inner{border:0}.mat-mini-fab.mat-button-disabled{cursor:default}.mat-mini-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-mini-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-mini-fab::-moz-focus-inner{border:0}._mat-animation-noopable.mat-mini-fab{transition:none;animation:none}.mat-mini-fab .mat-button-wrapper{padding:8px 0;display:inline-block;line-height:24px}.mat-icon-button{padding:0;min-width:0;width:40px;height:40px;flex-shrink:0;line-height:40px;border-radius:50%}.mat-icon-button i,.mat-icon-button .mat-icon{line-height:24px}.mat-button-ripple.mat-ripple,.mat-button-focus-overlay{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-button-ripple.mat-ripple:not(:empty){transform:translateZ(0)}.mat-button-focus-overlay{opacity:0;transition:opacity 200ms cubic-bezier(0.35, 0, 0.25, 1),background-color 200ms cubic-bezier(0.35, 0, 0.25, 1)}._mat-animation-noopable .mat-button-focus-overlay{transition:none}.mat-button-ripple-round{border-radius:50%;z-index:1}.mat-button .mat-button-wrapper>*,.mat-flat-button .mat-button-wrapper>*,.mat-stroked-button .mat-button-wrapper>*,.mat-raised-button .mat-button-wrapper>*,.mat-icon-button .mat-button-wrapper>*,.mat-fab .mat-button-wrapper>*,.mat-mini-fab .mat-button-wrapper>*{vertical-align:middle}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button{display:inline-flex;justify-content:center;align-items:center;font-size:inherit;width:2.5em;height:2.5em}.cdk-high-contrast-active .mat-button,.cdk-high-contrast-active .mat-flat-button,.cdk-high-contrast-active .mat-raised-button,.cdk-high-contrast-active .mat-icon-button,.cdk-high-contrast-active .mat-fab,.cdk-high-contrast-active .mat-mini-fab{outline:solid 1px}.cdk-high-contrast-active .mat-button-base.cdk-keyboard-focused,.cdk-high-contrast-active .mat-button-base.cdk-program-focused{outline:solid 3px}
</style><style>.docs-theme-picker-menu .mat-menu-item .mat-icon.theme-example-icon{margin-right:0;margin-left:8px;float:right}.docs-theme-picker-menu .mat-menu-item .mat-icon.theme-example-icon svg{vertical-align:middle}.docs-theme-picker-menu .mat-menu-item .mat-icon.theme-example-icon.deeppurple-amber svg .docs-theme-icon-background{fill:#fafafa}.docs-theme-picker-menu .mat-menu-item .mat-icon.theme-example-icon.deeppurple-amber svg .docs-theme-icon-button{fill:#ffc107}.docs-theme-picker-menu .mat-menu-item .mat-icon.theme-example-icon.deeppurple-amber svg .docs-theme-icon-toolbar{fill:#673ab7}.docs-theme-picker-menu .mat-menu-item .mat-icon.theme-example-icon.indigo-pink svg .docs-theme-icon-background{fill:#fafafa}.docs-theme-picker-menu .mat-menu-item .mat-icon.theme-example-icon.indigo-pink svg .docs-theme-icon-button{fill:#e91e63}.docs-theme-picker-menu .mat-menu-item .mat-icon.theme-example-icon.indigo-pink svg .docs-theme-icon-toolbar{fill:#3f51b5}.docs-theme-picker-menu .mat-menu-item .mat-icon.theme-example-icon.pink-bluegrey svg .docs-theme-icon-background{fill:#303030}.docs-theme-picker-menu .mat-menu-item .mat-icon.theme-example-icon.pink-bluegrey svg .docs-theme-icon-button{fill:#607d8b}.docs-theme-picker-menu .mat-menu-item .mat-icon.theme-example-icon.pink-bluegrey svg .docs-theme-icon-toolbar{fill:#e91e63}.docs-theme-picker-menu .mat-menu-item .mat-icon.theme-example-icon.purple-green svg .docs-theme-icon-background{fill:#303030}.docs-theme-picker-menu .mat-menu-item .mat-icon.theme-example-icon.purple-green svg .docs-theme-icon-button{fill:#4caf50}.docs-theme-picker-menu .mat-menu-item .mat-icon.theme-example-icon.purple-green svg .docs-theme-icon-toolbar{fill:#9c27b0}</style><style>.mat-icon{background-repeat:no-repeat;display:inline-block;fill:currentColor;height:24px;width:24px}.mat-icon.mat-icon-inline{font-size:inherit;height:inherit;line-height:inherit;width:inherit}[dir=rtl] .mat-icon-rtl-mirror{transform:scale(-1, 1)}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon{display:block}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button .mat-icon{margin:auto}
</style><style>mat-menu{display:none}.mat-menu-panel{min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;max-height:calc(100vh - 48px);border-radius:4px;outline:0;min-height:64px}.mat-menu-panel.ng-animating{pointer-events:none}.cdk-high-contrast-active .mat-menu-panel{outline:solid 1px}.mat-menu-content:not(:empty){padding-top:8px;padding-bottom:8px}.mat-menu-item{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;line-height:48px;height:48px;padding:0 16px;text-align:left;text-decoration:none;max-width:100%;position:relative}.mat-menu-item::-moz-focus-inner{border:0}.mat-menu-item[disabled]{cursor:default}[dir=rtl] .mat-menu-item{text-align:right}.mat-menu-item .mat-icon{margin-right:16px;vertical-align:middle}.mat-menu-item .mat-icon svg{vertical-align:top}[dir=rtl] .mat-menu-item .mat-icon{margin-left:16px;margin-right:0}.mat-menu-item[disabled]{pointer-events:none}.cdk-high-contrast-active .mat-menu-item{margin-top:1px}.cdk-high-contrast-active .mat-menu-item.cdk-program-focused,.cdk-high-contrast-active .mat-menu-item.cdk-keyboard-focused,.cdk-high-contrast-active .mat-menu-item-highlighted{outline:dotted 1px}.mat-menu-item-submenu-trigger{padding-right:32px}.mat-menu-item-submenu-trigger::after{width:0;height:0;border-style:solid;border-width:5px 0 5px 5px;border-color:transparent transparent transparent currentColor;content:"";display:inline-block;position:absolute;top:50%;right:16px;transform:translateY(-50%)}[dir=rtl] .mat-menu-item-submenu-trigger{padding-right:16px;padding-left:32px}[dir=rtl] .mat-menu-item-submenu-trigger::after{right:auto;left:16px;transform:rotateY(180deg) translateY(-50%)}button.mat-menu-item{width:100%}.mat-menu-item .mat-menu-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}
</style><style>app-component-sidenav{display:flex;flex-direction:column;overflow:auto}.docs-component-viewer-sidenav-container{flex:1;box-sizing:border-box}.docs-component-viewer-sidenav{overflow:auto}.docs-component-sidenav-inner-content{flex-direction:row}.mat-drawer::-webkit-scrollbar{height:4px;width:4px}.docs-component-viewer-nav{position:sticky;top:0}.docs-component-viewer-nav .docs-component-viewer-nav-content{width:240px;height:calc(100vh - 56px);overflow:auto}.docs-component-viewer-nav .docs-component-viewer-nav-content::-webkit-scrollbar{height:4px;width:4px}.docs-component-viewer-nav .docs-component-viewer-nav-content ul{list-style-type:none;margin:0 0 5px;padding:0;overflow:hidden}.docs-component-viewer-nav .docs-component-viewer-nav-content li{font-size:13px;line-height:16px;margin:0;padding:5px 15px 5px 20px}.docs-component-viewer-nav .docs-component-viewer-nav-content a{display:block;text-decoration:none}.docs-component-sidenav-content{display:flex;flex-direction:column;min-height:100%}.docs-component-sidenav-inner-content{display:flex;flex-direction:column;flex:1}.docs-component-sidenav-body-content{display:flex;flex:1 1 auto}div .mat-list-base{padding-top:0}div.docs-component-viewer-nav-content .mat-nav-list .mat-list-item .mat-list-item-content{padding-left:25px}@media (max-width:959px){.docs-component-viewer-sidenav-container .docs-component-viewer-sidenav{z-index:4}.docs-component-viewer-nav{position:relative;top:0}.docs-component-viewer-nav .docs-component-viewer-nav-content{box-sizing:border-box;margin:0;max-height:none}}@media (max-width:720px){.docs-component-viewer-sidenav-container{flex:1 0 auto}.docs-component-sidenav-body-content{flex-direction:column}}</style><style>.mat-drawer-container{position:relative;z-index:1;box-sizing:border-box;-webkit-overflow-scrolling:touch;display:block;overflow:hidden}.mat-drawer-container[fullscreen]{top:0;left:0;right:0;bottom:0;position:absolute}.mat-drawer-container[fullscreen].mat-drawer-container-has-open{overflow:hidden}.mat-drawer-container.mat-drawer-container-explicit-backdrop .mat-drawer-side{z-index:3}.mat-drawer-container.ng-animate-disabled .mat-drawer-backdrop,.mat-drawer-container.ng-animate-disabled .mat-drawer-content,.ng-animate-disabled .mat-drawer-container .mat-drawer-backdrop,.ng-animate-disabled .mat-drawer-container .mat-drawer-content{transition:none}.mat-drawer-backdrop{top:0;left:0;right:0;bottom:0;position:absolute;display:block;z-index:3;visibility:hidden}.mat-drawer-backdrop.mat-drawer-shown{visibility:visible}.mat-drawer-transition .mat-drawer-backdrop{transition-duration:400ms;transition-timing-function:cubic-bezier(0.25, 0.8, 0.25, 1);transition-property:background-color,visibility}.cdk-high-contrast-active .mat-drawer-backdrop{opacity:.5}.mat-drawer-content{position:relative;z-index:1;display:block;height:100%;overflow:auto}.mat-drawer-transition .mat-drawer-content{transition-duration:400ms;transition-timing-function:cubic-bezier(0.25, 0.8, 0.25, 1);transition-property:transform,margin-left,margin-right}.mat-drawer{position:relative;z-index:4;display:block;position:absolute;top:0;bottom:0;z-index:3;outline:0;box-sizing:border-box;overflow-y:auto;transform:translate3d(-100%, 0, 0)}.cdk-high-contrast-active .mat-drawer,.cdk-high-contrast-active [dir=rtl] .mat-drawer.mat-drawer-end{border-right:solid 1px currentColor}.cdk-high-contrast-active [dir=rtl] .mat-drawer,.cdk-high-contrast-active .mat-drawer.mat-drawer-end{border-left:solid 1px currentColor;border-right:none}.mat-drawer.mat-drawer-side{z-index:2}.mat-drawer.mat-drawer-end{right:0;transform:translate3d(100%, 0, 0)}[dir=rtl] .mat-drawer{transform:translate3d(100%, 0, 0)}[dir=rtl] .mat-drawer.mat-drawer-end{left:0;right:auto;transform:translate3d(-100%, 0, 0)}.mat-drawer-inner-container{width:100%;height:100%;overflow:auto;-webkit-overflow-scrolling:touch}.mat-sidenav-fixed{position:fixed}
</style><style>.component-page-header[_ngcontent-material-docs-c123]{display:flex;align-items:center}@media (max-width:959px){.component-page-header[_ngcontent-material-docs-c123]{padding-left:0}}h1[_ngcontent-material-docs-c123]{outline:none}@media (max-width:959px){h1[_ngcontent-material-docs-c123]{padding:24px 8px;font-size:20px}}.sidenav-toggle[_ngcontent-material-docs-c123]{padding:0;margin:8px;min-width:64px;display:none}@media (max-width:959px){.sidenav-toggle[_ngcontent-material-docs-c123]{display:flex;align-items:center;justify-content:center}}.sidenav-toggle[_ngcontent-material-docs-c123]   mat-icon[_ngcontent-material-docs-c123]{font-size:30px;height:64px;width:64px;line-height:64px;color:#fff}</style><style>.docs-footer[_ngcontent-material-docs-c112]{padding:12px;font-size:12px}.docs-footer-list[_ngcontent-material-docs-c112]{align-items:center;display:flex;flex-flow:row wrap;padding:8px}.docs-footer-logo[_ngcontent-material-docs-c112]{flex:1}.docs-footer-angular-logo[_ngcontent-material-docs-c112]{height:50px}.docs-footer-version[_ngcontent-material-docs-c112]{display:flex;justify-content:center;align-items:center;flex:1}.docs-footer-version[_ngcontent-material-docs-c112]   .angular-material-logo[_ngcontent-material-docs-c112]{height:40px;margin:10px 0 10px 16px}.docs-footer-version[_ngcontent-material-docs-c112]   .version[_ngcontent-material-docs-c112]{margin:0 40px}.docs-footer-copyright[_ngcontent-material-docs-c112]{display:flex;flex:1;justify-content:flex-end;flex-direction:column;min-width:225px;margin-top:16px}.docs-footer-copyright[_ngcontent-material-docs-c112] > div[_ngcontent-material-docs-c112]{display:flex;flex-direction:column;align-self:flex-end;text-align:center}@media (min-width:885px){.docs-footer-copyright[_ngcontent-material-docs-c112]{margin-top:0}}.docs-footer-logo[_ngcontent-material-docs-c112]   span[_ngcontent-material-docs-c112]{display:inline-block;line-height:50px;margin:0 40px;vertical-align:bottom}.docs-footer-logo[_ngcontent-material-docs-c112]   span[_ngcontent-material-docs-c112]   a[_ngcontent-material-docs-c112]{font-size:16px;padding:0}a[_ngcontent-material-docs-c112]{text-decoration:none;color:inherit}a[_ngcontent-material-docs-c112]:focus, a[_ngcontent-material-docs-c112]:hover{text-decoration:underline}@media screen and (max-width:884px){.docs-footer-list[_ngcontent-material-docs-c112]{flex-direction:column}}</style><style>app-component-viewer{font-weight:400;width:calc(100% - 241px - 100px);padding:20px 50px}@media (max-width:959px){app-component-viewer{width:calc(100% - 100px)}}@media (max-width:599px){app-component-viewer{width:calc(100% - 30px);padding-left:15px;padding-right:15px}}.docs-component-viewer-section-tab{text-transform:uppercase}.docs-component-viewer-tabbed-content{margin-bottom:25px}.docs-component-viewer-content{position:relative;min-height:500px}.docs-component-viewer-content component-api,.docs-component-viewer-content component-overview{display:flex;align-items:flex-start;overflow:visible}@media (max-width:959px){.docs-component-viewer-content component-api,.docs-component-viewer-content component-overview{flex-direction:column}}.docs-component-viewer-content table-of-contents{top:35px;position:sticky}@media (max-width:959px){.docs-component-viewer-content table-of-contents{order:-1;position:inherit;width:auto;padding-left:0}}.docs-component-view-text-content{flex-grow:1;width:100%}.docs-component-api,.docs-component-overview{width:80%}@media (max-width:959px){.docs-component-api,.docs-component-overview{width:100%;margin-right:0}}</style><style>.mat-tab-header{display:flex;overflow:hidden;position:relative;flex-shrink:0}.mat-tab-header-pagination{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;position:relative;display:none;justify-content:center;align-items:center;min-width:32px;cursor:pointer;z-index:2;-webkit-tap-highlight-color:transparent;touch-action:none}.mat-tab-header-pagination-controls-enabled .mat-tab-header-pagination{display:flex}.mat-tab-header-pagination-before,.mat-tab-header-rtl .mat-tab-header-pagination-after{padding-left:4px}.mat-tab-header-pagination-before .mat-tab-header-pagination-chevron,.mat-tab-header-rtl .mat-tab-header-pagination-after .mat-tab-header-pagination-chevron{transform:rotate(-135deg)}.mat-tab-header-rtl .mat-tab-header-pagination-before,.mat-tab-header-pagination-after{padding-right:4px}.mat-tab-header-rtl .mat-tab-header-pagination-before .mat-tab-header-pagination-chevron,.mat-tab-header-pagination-after .mat-tab-header-pagination-chevron{transform:rotate(45deg)}.mat-tab-header-pagination-chevron{border-style:solid;border-width:2px 2px 0 0;content:"";height:8px;width:8px}.mat-tab-header-pagination-disabled{box-shadow:none;cursor:default}.mat-tab-list{flex-grow:1;position:relative;transition:transform 500ms cubic-bezier(0.35, 0, 0.25, 1)}.mat-tab-links{display:flex}[mat-align-tabs=center]>.mat-tab-link-container .mat-tab-links{justify-content:center}[mat-align-tabs=end]>.mat-tab-link-container .mat-tab-links{justify-content:flex-end}.mat-ink-bar{position:absolute;bottom:0;height:2px;transition:500ms cubic-bezier(0.35, 0, 0.25, 1)}._mat-animation-noopable.mat-ink-bar{transition:none;animation:none}.mat-tab-group-inverted-header .mat-ink-bar{bottom:auto;top:0}.cdk-high-contrast-active .mat-ink-bar{outline:solid 2px;height:0}.mat-tab-link-container{display:flex;flex-grow:1;overflow:hidden;z-index:1}.mat-tab-link{height:48px;padding:0 24px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;display:inline-flex;justify-content:center;align-items:center;white-space:nowrap;vertical-align:top;text-decoration:none;position:relative;overflow:hidden;-webkit-tap-highlight-color:transparent}.mat-tab-link:focus{outline:none}.mat-tab-link:focus:not(.mat-tab-disabled){opacity:1}.cdk-high-contrast-active .mat-tab-link:focus{outline:dotted 2px;outline-offset:-2px}.mat-tab-link.mat-tab-disabled{cursor:default}.cdk-high-contrast-active .mat-tab-link.mat-tab-disabled{opacity:.5}.mat-tab-link .mat-tab-label-content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}.cdk-high-contrast-active .mat-tab-link{opacity:1}[mat-stretch-tabs] .mat-tab-link{flex-basis:0;flex-grow:1}.mat-tab-link.mat-tab-disabled{pointer-events:none}@media(max-width: 599px){.mat-tab-link{min-width:72px}}
</style><style>.mat-subheader{display:flex;box-sizing:border-box;padding:16px;align-items:center}.mat-list-base .mat-subheader{margin:0}.mat-list-base{padding-top:8px;display:block;-webkit-tap-highlight-color:transparent}.mat-list-base .mat-subheader{height:48px;line-height:16px}.mat-list-base .mat-subheader:first-child{margin-top:-8px}.mat-list-base .mat-list-item,.mat-list-base .mat-list-option{display:block;height:48px;-webkit-tap-highlight-color:transparent;width:100%;padding:0}.mat-list-base .mat-list-item .mat-list-item-content,.mat-list-base .mat-list-option .mat-list-item-content{display:flex;flex-direction:row;align-items:center;box-sizing:border-box;padding:0 16px;position:relative;height:inherit}.mat-list-base .mat-list-item .mat-list-item-content-reverse,.mat-list-base .mat-list-option .mat-list-item-content-reverse{display:flex;align-items:center;padding:0 16px;flex-direction:row-reverse;justify-content:space-around}.mat-list-base .mat-list-item .mat-list-item-ripple,.mat-list-base .mat-list-option .mat-list-item-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}.mat-list-base .mat-list-item.mat-list-item-with-avatar,.mat-list-base .mat-list-option.mat-list-item-with-avatar{height:56px}.mat-list-base .mat-list-item.mat-2-line,.mat-list-base .mat-list-option.mat-2-line{height:72px}.mat-list-base .mat-list-item.mat-3-line,.mat-list-base .mat-list-option.mat-3-line{height:88px}.mat-list-base .mat-list-item.mat-multi-line,.mat-list-base .mat-list-option.mat-multi-line{height:auto}.mat-list-base .mat-list-item.mat-multi-line .mat-list-item-content,.mat-list-base .mat-list-option.mat-multi-line .mat-list-item-content{padding-top:16px;padding-bottom:16px}.mat-list-base .mat-list-item .mat-list-text,.mat-list-base .mat-list-option .mat-list-text{display:flex;flex-direction:column;flex:auto;box-sizing:border-box;overflow:hidden;padding:0}.mat-list-base .mat-list-item .mat-list-text>*,.mat-list-base .mat-list-option .mat-list-text>*{margin:0;padding:0;font-weight:normal;font-size:inherit}.mat-list-base .mat-list-item .mat-list-text:empty,.mat-list-base .mat-list-option .mat-list-text:empty{display:none}.mat-list-base .mat-list-item.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,.mat-list-base .mat-list-item.mat-list-option .mat-list-item-content .mat-list-text,.mat-list-base .mat-list-option.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,.mat-list-base .mat-list-option.mat-list-option .mat-list-item-content .mat-list-text{padding-right:0;padding-left:16px}[dir=rtl] .mat-list-base .mat-list-item.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base .mat-list-item.mat-list-option .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base .mat-list-option.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base .mat-list-option.mat-list-option .mat-list-item-content .mat-list-text{padding-right:16px;padding-left:0}.mat-list-base .mat-list-item.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,.mat-list-base .mat-list-item.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base .mat-list-option.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,.mat-list-base .mat-list-option.mat-list-option .mat-list-item-content-reverse .mat-list-text{padding-left:0;padding-right:16px}[dir=rtl] .mat-list-base .mat-list-item.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base .mat-list-item.mat-list-option .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base .mat-list-option.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base .mat-list-option.mat-list-option .mat-list-item-content-reverse .mat-list-text{padding-right:0;padding-left:16px}.mat-list-base .mat-list-item.mat-list-item-with-avatar.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base .mat-list-item.mat-list-item-with-avatar.mat-list-option .mat-list-item-content .mat-list-text,.mat-list-base .mat-list-option.mat-list-item-with-avatar.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base .mat-list-option.mat-list-item-with-avatar.mat-list-option .mat-list-item-content .mat-list-text{padding-right:16px;padding-left:16px}.mat-list-base .mat-list-item .mat-list-avatar,.mat-list-base .mat-list-option .mat-list-avatar{flex-shrink:0;width:40px;height:40px;border-radius:50%;object-fit:cover}.mat-list-base .mat-list-item .mat-list-avatar~.mat-divider-inset,.mat-list-base .mat-list-option .mat-list-avatar~.mat-divider-inset{margin-left:72px;width:calc(100% - 72px)}[dir=rtl] .mat-list-base .mat-list-item .mat-list-avatar~.mat-divider-inset,[dir=rtl] .mat-list-base .mat-list-option .mat-list-avatar~.mat-divider-inset{margin-left:auto;margin-right:72px}.mat-list-base .mat-list-item .mat-list-icon,.mat-list-base .mat-list-option .mat-list-icon{flex-shrink:0;width:24px;height:24px;font-size:24px;box-sizing:content-box;border-radius:50%;padding:4px}.mat-list-base .mat-list-item .mat-list-icon~.mat-divider-inset,.mat-list-base .mat-list-option .mat-list-icon~.mat-divider-inset{margin-left:64px;width:calc(100% - 64px)}[dir=rtl] .mat-list-base .mat-list-item .mat-list-icon~.mat-divider-inset,[dir=rtl] .mat-list-base .mat-list-option .mat-list-icon~.mat-divider-inset{margin-left:auto;margin-right:64px}.mat-list-base .mat-list-item .mat-divider,.mat-list-base .mat-list-option .mat-divider{position:absolute;bottom:0;left:0;width:100%;margin:0}[dir=rtl] .mat-list-base .mat-list-item .mat-divider,[dir=rtl] .mat-list-base .mat-list-option .mat-divider{margin-left:auto;margin-right:0}.mat-list-base .mat-list-item .mat-divider.mat-divider-inset,.mat-list-base .mat-list-option .mat-divider.mat-divider-inset{position:absolute}.mat-list-base[dense]{padding-top:4px;display:block}.mat-list-base[dense] .mat-subheader{height:40px;line-height:8px}.mat-list-base[dense] .mat-subheader:first-child{margin-top:-4px}.mat-list-base[dense] .mat-list-item,.mat-list-base[dense] .mat-list-option{display:block;height:40px;-webkit-tap-highlight-color:transparent;width:100%;padding:0}.mat-list-base[dense] .mat-list-item .mat-list-item-content,.mat-list-base[dense] .mat-list-option .mat-list-item-content{display:flex;flex-direction:row;align-items:center;box-sizing:border-box;padding:0 16px;position:relative;height:inherit}.mat-list-base[dense] .mat-list-item .mat-list-item-content-reverse,.mat-list-base[dense] .mat-list-option .mat-list-item-content-reverse{display:flex;align-items:center;padding:0 16px;flex-direction:row-reverse;justify-content:space-around}.mat-list-base[dense] .mat-list-item .mat-list-item-ripple,.mat-list-base[dense] .mat-list-option .mat-list-item-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}.mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar,.mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar{height:48px}.mat-list-base[dense] .mat-list-item.mat-2-line,.mat-list-base[dense] .mat-list-option.mat-2-line{height:60px}.mat-list-base[dense] .mat-list-item.mat-3-line,.mat-list-base[dense] .mat-list-option.mat-3-line{height:76px}.mat-list-base[dense] .mat-list-item.mat-multi-line,.mat-list-base[dense] .mat-list-option.mat-multi-line{height:auto}.mat-list-base[dense] .mat-list-item.mat-multi-line .mat-list-item-content,.mat-list-base[dense] .mat-list-option.mat-multi-line .mat-list-item-content{padding-top:16px;padding-bottom:16px}.mat-list-base[dense] .mat-list-item .mat-list-text,.mat-list-base[dense] .mat-list-option .mat-list-text{display:flex;flex-direction:column;flex:auto;box-sizing:border-box;overflow:hidden;padding:0}.mat-list-base[dense] .mat-list-item .mat-list-text>*,.mat-list-base[dense] .mat-list-option .mat-list-text>*{margin:0;padding:0;font-weight:normal;font-size:inherit}.mat-list-base[dense] .mat-list-item .mat-list-text:empty,.mat-list-base[dense] .mat-list-option .mat-list-text:empty{display:none}.mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,.mat-list-base[dense] .mat-list-item.mat-list-option .mat-list-item-content .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-option .mat-list-item-content .mat-list-text{padding-right:0;padding-left:16px}[dir=rtl] .mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-item.mat-list-option .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-option.mat-list-option .mat-list-item-content .mat-list-text{padding-right:16px;padding-left:0}.mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,.mat-list-base[dense] .mat-list-item.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-option .mat-list-item-content-reverse .mat-list-text{padding-left:0;padding-right:16px}[dir=rtl] .mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-item.mat-list-option .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-option.mat-list-option .mat-list-item-content-reverse .mat-list-text{padding-right:0;padding-left:16px}.mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar.mat-list-option .mat-list-item-content .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar.mat-list-option .mat-list-item-content .mat-list-text{padding-right:16px;padding-left:16px}.mat-list-base[dense] .mat-list-item .mat-list-avatar,.mat-list-base[dense] .mat-list-option .mat-list-avatar{flex-shrink:0;width:36px;height:36px;border-radius:50%;object-fit:cover}.mat-list-base[dense] .mat-list-item .mat-list-avatar~.mat-divider-inset,.mat-list-base[dense] .mat-list-option .mat-list-avatar~.mat-divider-inset{margin-left:68px;width:calc(100% - 68px)}[dir=rtl] .mat-list-base[dense] .mat-list-item .mat-list-avatar~.mat-divider-inset,[dir=rtl] .mat-list-base[dense] .mat-list-option .mat-list-avatar~.mat-divider-inset{margin-left:auto;margin-right:68px}.mat-list-base[dense] .mat-list-item .mat-list-icon,.mat-list-base[dense] .mat-list-option .mat-list-icon{flex-shrink:0;width:20px;height:20px;font-size:20px;box-sizing:content-box;border-radius:50%;padding:4px}.mat-list-base[dense] .mat-list-item .mat-list-icon~.mat-divider-inset,.mat-list-base[dense] .mat-list-option .mat-list-icon~.mat-divider-inset{margin-left:60px;width:calc(100% - 60px)}[dir=rtl] .mat-list-base[dense] .mat-list-item .mat-list-icon~.mat-divider-inset,[dir=rtl] .mat-list-base[dense] .mat-list-option .mat-list-icon~.mat-divider-inset{margin-left:auto;margin-right:60px}.mat-list-base[dense] .mat-list-item .mat-divider,.mat-list-base[dense] .mat-list-option .mat-divider{position:absolute;bottom:0;left:0;width:100%;margin:0}[dir=rtl] .mat-list-base[dense] .mat-list-item .mat-divider,[dir=rtl] .mat-list-base[dense] .mat-list-option .mat-divider{margin-left:auto;margin-right:0}.mat-list-base[dense] .mat-list-item .mat-divider.mat-divider-inset,.mat-list-base[dense] .mat-list-option .mat-divider.mat-divider-inset{position:absolute}.mat-nav-list a{text-decoration:none;color:inherit}.mat-nav-list .mat-list-item{cursor:pointer;outline:none}mat-action-list button{background:none;color:inherit;border:none;font:inherit;outline:inherit;-webkit-tap-highlight-color:transparent;text-align:left}[dir=rtl] mat-action-list button{text-align:right}mat-action-list button::-moz-focus-inner{border:0}mat-action-list .mat-list-item{cursor:pointer;outline:inherit}.mat-list-option:not(.mat-list-item-disabled){cursor:pointer;outline:none}.mat-list-item-disabled{pointer-events:none}.cdk-high-contrast-active .mat-list-item-disabled{opacity:.5}.cdk-high-contrast-active :host .mat-list-item-disabled{opacity:.5}.cdk-high-contrast-active .mat-selection-list:focus{outline-style:dotted}.cdk-high-contrast-active .mat-list-option:hover,.cdk-high-contrast-active .mat-list-option:focus,.cdk-high-contrast-active .mat-nav-list .mat-list-item:hover,.cdk-high-contrast-active .mat-nav-list .mat-list-item:focus,.cdk-high-contrast-active mat-action-list .mat-list-item:hover,.cdk-high-contrast-active mat-action-list .mat-list-item:focus{outline:dotted 1px}.cdk-high-contrast-active .mat-list-single-selected-option::after{content:"";position:absolute;top:50%;right:16px;transform:translateY(-50%);width:10px;height:0;border-bottom:solid 10px;border-radius:10px}.cdk-high-contrast-active [dir=rtl] .mat-list-single-selected-option::after{right:auto;left:16px}@media(hover: none){.mat-list-option:not(.mat-list-single-selected-option):not(.mat-list-item-disabled):hover,.mat-nav-list .mat-list-item:not(.mat-list-item-disabled):hover,.mat-action-list .mat-list-item:not(.mat-list-item-disabled):hover{background:none}}
</style><style>[_nghost-material-docs-c124]{font-size:13px;width:19%;position:sticky;top:0;padding-left:25px;box-sizing:border-box;display:inline-flex;flex-direction:column}.docs-toc-container[_ngcontent-material-docs-c124]{width:100%;padding:5px 0 10px 10px}.docs-toc-container[_ngcontent-material-docs-c124] + .docs-toc-container[_ngcontent-material-docs-c124]{padding-top:8px}.docs-toc-heading[_ngcontent-material-docs-c124]{margin:0;padding:0;font-size:13px;font-weight:700;text-transform:capitalize}a[_ngcontent-material-docs-c124]{line-height:16px;margin:8px 0 0;position:relative;text-decoration:none;display:block;text-overflow:ellipsis;width:100%;overflow:hidden}.docs-level-h4[_ngcontent-material-docs-c124]{margin-left:12px}</style></head>

<body class="docs-app-background">
<material-docs-app ng-version="12.0.0"><app-navbar class="mat-elevation-z6" _nghost-material-docs-c46=""><nav _ngcontent-material-docs-c46="" aria-label="Top Toolbar" class="docs-navbar-header"><!----><a _ngcontent-material-docs-c46="" mat-button="" routerlink="/" aria-label="Angular Material" class="mat-focus-indicator docs-button mat-button mat-button-base" tabindex="0" aria-disabled="false" href="/"><span class="mat-button-wrapper"><img _ngcontent-material-docs-c46="" src="../../../assets/img/homepage/angular-white-transparent.svg" alt="angular" class="docs-angular-logo"><span _ngcontent-material-docs-c46="">Material</span></span><span matripple="" class="mat-ripple mat-button-ripple"></span><span class="mat-button-focus-overlay"></span></a><a _ngcontent-material-docs-c46="" mat-button="" class="mat-focus-indicator docs-navbar-hide-small docs-button mat-button mat-button-base ng-star-inserted" tabindex="0" aria-disabled="false" href="/components"><span class="mat-button-wrapper">组件</span><span matripple="" class="mat-ripple mat-button-ripple"></span><span class="mat-button-focus-overlay"></span></a><a _ngcontent-material-docs-c46="" mat-button="" class="mat-focus-indicator docs-navbar-hide-small docs-button mat-button mat-button-base ng-star-inserted" tabindex="0" aria-disabled="false" href="/cdk"><span class="mat-button-wrapper">组件开发包</span><span matripple="" class="mat-ripple mat-button-ripple"></span><span class="mat-button-focus-overlay"></span></a><!----><a _ngcontent-material-docs-c46="" mat-button="" routerlink="guides" class="mat-focus-indicator docs-navbar-hide-small docs-button mat-button mat-button-base" tabindex="0" aria-disabled="false" href="/guides"><span class="mat-button-wrapper">指南</span><span matripple="" class="mat-ripple mat-button-ripple"></span><span class="mat-button-focus-overlay"></span></a><div _ngcontent-material-docs-c46="" class="flex-spacer"></div><version-picker _ngcontent-material-docs-c46=""><button aria-haspopup="true" mat-button="" aria-label="Select a version" mattooltip="选择文档版本" class="mat-focus-indicator mat-tooltip-trigger mat-menu-trigger mat-button mat-button-base" aria-describedby="cdk-describedby-message-0" cdk-describedby-host=""><span class="mat-button-wrapper"> 12.0.1 <mat-icon role="img" class="mat-icon notranslate material-icons mat-icon-no-color" aria-hidden="true" data-mat-icon-type="font">arrow_drop_down</mat-icon></span><span matripple="" class="mat-ripple mat-button-ripple"></span><span class="mat-button-focus-overlay"></span></button><!----><mat-menu class="ng-tns-c37-0"><!----></mat-menu></version-picker><theme-picker _ngcontent-material-docs-c46=""><button aria-haspopup="true" mat-icon-button="" aria-label="Select a theme" mattooltip="选择文档的主题" class="mat-focus-indicator mat-tooltip-trigger mat-menu-trigger mat-icon-button mat-button-base" aria-describedby="cdk-describedby-message-1" cdk-describedby-host=""><span class="mat-button-wrapper"><mat-icon role="img" class="mat-icon notranslate material-icons mat-icon-no-color" aria-hidden="true" data-mat-icon-type="font">format_color_fill</mat-icon></span><span matripple="" class="mat-ripple mat-button-ripple mat-button-ripple-round"></span><span class="mat-button-focus-overlay"></span></button><!----><mat-menu xposition="before" class=""><!----></mat-menu></theme-picker><a _ngcontent-material-docs-c46="" mat-button="" href="https://github.com/ng-docs/components" target="_blank" aria-label="GitHub Repository" class="mat-focus-indicator docs-button docs-navbar-hide-small mat-button mat-button-base" tabindex="0" aria-disabled="false"><span class="mat-button-wrapper"><img _ngcontent-material-docs-c46="" src="../../../assets/img/homepage/github-circle-white-transparent.svg" alt="angular" class="docs-angular-logo"> GitHub </span><span matripple="" class="mat-ripple mat-button-ripple"></span><span class="mat-button-focus-overlay"></span></a><a _ngcontent-material-docs-c46="" mat-icon-button="" href="https://github.com/angular/components" aria-label="GitHub Repository" class="mat-focus-indicator docs-button docs-navbar-show-small mat-icon-button mat-button-base" tabindex="0" aria-disabled="false"><span class="mat-button-wrapper"><img _ngcontent-material-docs-c46="" src="../../../assets/img/homepage/github-circle-white-transparent.svg" alt="angular" class="docs-angular-logo"></span><span matripple="" class="mat-ripple mat-button-ripple mat-button-ripple-round"></span><span class="mat-button-focus-overlay"></span></a></nav><nav _ngcontent-material-docs-c46="" aria-label="Section Nav Bar" class="docs-navbar docs-navbar-show-small"><a _ngcontent-material-docs-c46="" mat-button="" class="mat-focus-indicator docs-navbar-link mat-button mat-button-base ng-star-inserted" tabindex="0" aria-disabled="false" href="/components"><span class="mat-button-wrapper">组件</span><span matripple="" class="mat-ripple mat-button-ripple"></span><span class="mat-button-focus-overlay"></span></a><a _ngcontent-material-docs-c46="" mat-button="" class="mat-focus-indicator docs-navbar-link mat-button mat-button-base ng-star-inserted" tabindex="0" aria-disabled="false" href="/cdk"><span class="mat-button-wrapper">组件开发包</span><span matripple="" class="mat-ripple mat-button-ripple"></span><span class="mat-button-focus-overlay"></span></a><!----><a _ngcontent-material-docs-c46="" mat-button="" routerlink="guides" class="mat-focus-indicator docs-navbar-link mat-button mat-button-base" tabindex="0" aria-disabled="false" href="/guides"><span class="mat-button-wrapper">指南</span><span matripple="" class="mat-ripple mat-button-ripple"></span><span class="mat-button-focus-overlay"></span></a></nav></app-navbar><router-outlet></router-outlet><app-component-sidenav class="ng-star-inserted"><mat-sidenav-container class="mat-drawer-container mat-sidenav-container docs-component-viewer-sidenav-container"><div class="mat-drawer-backdrop ng-star-inserted"></div><!----><!----><mat-sidenav-content cdkscrollable="" class="mat-drawer-content mat-sidenav-content ng-star-inserted"><div class="docs-component-sidenav-content"><component-page-header _nghost-material-docs-c123=""><header _ngcontent-material-docs-c123="" class="docs-primary-header component-page-header"><button _ngcontent-material-docs-c123="" mat-button="" class="mat-focus-indicator sidenav-toggle mat-button mat-button-base"><span class="mat-button-wrapper"><mat-icon _ngcontent-material-docs-c123="" role="img" class="mat-icon notranslate material-icons mat-icon-no-color" aria-hidden="true" data-mat-icon-type="font">menu</mat-icon></span><span matripple="" class="mat-ripple mat-button-ripple"></span><span class="mat-button-focus-overlay"></span></button><h1 _ngcontent-material-docs-c123="">组件测试工具 <small _ngcontent-material-docs-c123="">Component Harnesses</small></h1></header></component-page-header><div class="docs-component-sidenav-inner-content"><main class="docs-component-sidenav-body-content"><app-component-nav class="ng-tns-c131-2 ng-star-inserted"><div class="docs-component-viewer-nav ng-tns-c131-2"><div class="docs-component-viewer-nav-content ng-tns-c131-2 ng-star-inserted"><mat-nav-list role="navigation" class="mat-nav-list mat-list-base ng-tns-c131-2"><a mat-list-item="" routerlinkactive="docs-component-viewer-sidenav-item-selected" class="mat-list-item mat-focus-indicator ng-tns-c131-2 ng-star-inserted" aria-current="false" href="/cdk/a11y"><div class="mat-list-item-content"><div mat-ripple="" class="mat-ripple mat-list-item-ripple"></div><div class="mat-list-text"></div> 无障碍性&nbsp;<small>Accessibility</small></div></a><a mat-list-item="" routerlinkactive="docs-component-viewer-sidenav-item-selected" class="mat-list-item mat-focus-indicator ng-tns-c131-2 ng-star-inserted" aria-current="false" href="/cdk/bidi"><div class="mat-list-item-content"><div mat-ripple="" class="mat-ripple mat-list-item-ripple"></div><div class="mat-list-text"></div> 文字方向&nbsp;<small>Bidirectionality</small></div></a><a mat-list-item="" routerlinkactive="docs-component-viewer-sidenav-item-selected" class="mat-list-item mat-focus-indicator ng-tns-c131-2 ng-star-inserted" aria-current="false" href="/cdk/clipboard"><div class="mat-list-item-content"><div mat-ripple="" class="mat-ripple mat-list-item-ripple"></div><div class="mat-list-text"></div> 剪贴板&nbsp;<small>Clipboard</small></div></a><a mat-list-item="" routerlinkactive="docs-component-viewer-sidenav-item-selected" class="mat-list-item mat-focus-indicator ng-tns-c131-2 ng-star-inserted" aria-current="false" href="/cdk/drag-drop"><div class="mat-list-item-content"><div mat-ripple="" class="mat-ripple mat-list-item-ripple"></div><div class="mat-list-text"></div> 拖放&nbsp;<small>Drag and Drop</small></div></a><a mat-list-item="" routerlinkactive="docs-component-viewer-sidenav-item-selected" class="mat-list-item mat-focus-indicator ng-tns-c131-2 ng-star-inserted" aria-current="false" href="/cdk/layout"><div class="mat-list-item-content"><div mat-ripple="" class="mat-ripple mat-list-item-ripple"></div><div class="mat-list-text"></div> 布局&nbsp;<small>Layout</small></div></a><a mat-list-item="" routerlinkactive="docs-component-viewer-sidenav-item-selected" class="mat-list-item mat-focus-indicator ng-tns-c131-2 ng-star-inserted" aria-current="false" href="/cdk/observers"><div class="mat-list-item-content"><div mat-ripple="" class="mat-ripple mat-list-item-ripple"></div><div class="mat-list-text"></div> 观察者&nbsp;<small>Observers</small></div></a><a mat-list-item="" routerlinkactive="docs-component-viewer-sidenav-item-selected" class="mat-list-item mat-focus-indicator ng-tns-c131-2 ng-star-inserted" aria-current="false" href="/cdk/overlay"><div class="mat-list-item-content"><div mat-ripple="" class="mat-ripple mat-list-item-ripple"></div><div class="mat-list-text"></div> 浮层&nbsp;<small>Overlay</small></div></a><a mat-list-item="" routerlinkactive="docs-component-viewer-sidenav-item-selected" class="mat-list-item mat-focus-indicator ng-tns-c131-2 ng-star-inserted" aria-current="false" href="/cdk/platform"><div class="mat-list-item-content"><div mat-ripple="" class="mat-ripple mat-list-item-ripple"></div><div class="mat-list-text"></div> 平台&nbsp;<small>Platform</small></div></a><a mat-list-item="" routerlinkactive="docs-component-viewer-sidenav-item-selected" class="mat-list-item mat-focus-indicator ng-tns-c131-2 ng-star-inserted" aria-current="false" href="/cdk/portal"><div class="mat-list-item-content"><div mat-ripple="" class="mat-ripple mat-list-item-ripple"></div><div class="mat-list-text"></div> 传送点&nbsp;<small>Portal</small></div></a><a mat-list-item="" routerlinkactive="docs-component-viewer-sidenav-item-selected" class="mat-list-item mat-focus-indicator ng-tns-c131-2 ng-star-inserted" aria-current="false" href="/cdk/scrolling"><div class="mat-list-item-content"><div mat-ripple="" class="mat-ripple mat-list-item-ripple"></div><div class="mat-list-text"></div> 滚动&nbsp;<small>Scrolling</small></div></a><a mat-list-item="" routerlinkactive="docs-component-viewer-sidenav-item-selected" class="mat-list-item mat-focus-indicator ng-tns-c131-2 ng-star-inserted" aria-current="false" href="/cdk/stepper"><div class="mat-list-item-content"><div mat-ripple="" class="mat-ripple mat-list-item-ripple"></div><div class="mat-list-text"></div> 步进器&nbsp;<small>Stepper</small></div></a><a mat-list-item="" routerlinkactive="docs-component-viewer-sidenav-item-selected" class="mat-list-item mat-focus-indicator ng-tns-c131-2 ng-star-inserted" aria-current="false" href="/cdk/table"><div class="mat-list-item-content"><div mat-ripple="" class="mat-ripple mat-list-item-ripple"></div><div class="mat-list-text"></div> 表格&nbsp;<small>Table</small></div></a><a mat-list-item="" routerlinkactive="docs-component-viewer-sidenav-item-selected" class="mat-list-item mat-focus-indicator ng-tns-c131-2 ng-star-inserted docs-component-viewer-sidenav-item-selected" aria-current="false" href="/cdk/test-harnesses"><div class="mat-list-item-content"><div mat-ripple="" class="mat-ripple mat-list-item-ripple"></div><div class="mat-list-text"></div> 组件测试工具&nbsp;<small>Component Harnesses</small></div></a><a mat-list-item="" routerlinkactive="docs-component-viewer-sidenav-item-selected" class="mat-list-item mat-focus-indicator ng-tns-c131-2 ng-star-inserted" aria-current="false" href="/cdk/text-field"><div class="mat-list-item-content"><div mat-ripple="" class="mat-ripple mat-list-item-ripple"></div><div class="mat-list-text"></div> 文本字段&nbsp;<small>Text field</small></div></a><a mat-list-item="" routerlinkactive="docs-component-viewer-sidenav-item-selected" class="mat-list-item mat-focus-indicator ng-tns-c131-2 ng-star-inserted" aria-current="false" href="/cdk/tree"><div class="mat-list-item-content"><div mat-ripple="" class="mat-ripple mat-list-item-ripple"></div><div class="mat-list-text"></div> 树&nbsp;<small>Tree</small></div></a><!----></mat-nav-list></div><!----></div></app-component-nav><!----><router-outlet></router-outlet><app-component-viewer class="ng-star-inserted"><div class="docs-component-viewer"><nav mat-tab-nav-bar="" aria-label="Documentation Sections" id="component-viewer" focusonnavigation="" class="mat-tab-nav-bar mat-tab-header docs-component-viewer-tabbed-content mat-primary" tabindex="-1" style="outline: none;"><div aria-hidden="true" mat-ripple="" class="mat-ripple mat-tab-header-pagination mat-tab-header-pagination-before mat-elevation-z4 mat-tab-header-pagination-disabled"><div class="mat-tab-header-pagination-chevron"></div></div><div class="mat-tab-link-container"><div class="mat-tab-list" style="transform: translateX(0px);"><div class="mat-tab-links"><a mat-tab-link="" routerlinkactive="" class="mat-tab-link mat-focus-indicator docs-component-viewer-section-tab ng-star-inserted mat-tab-label-active" href="/cdk/test-harnesses/overview" aria-disabled="false" tabindex="0" aria-current="page">概览</a><a mat-tab-link="" routerlinkactive="" class="mat-tab-link mat-focus-indicator docs-component-viewer-section-tab ng-star-inserted" href="/cdk/test-harnesses/api" aria-disabled="false" tabindex="0">API</a><!----></div><mat-ink-bar class="mat-ink-bar" style="visibility: visible; left: 0px; width: 160px;"></mat-ink-bar></div></div><div aria-hidden="true" mat-ripple="" class="mat-ripple mat-tab-header-pagination mat-tab-header-pagination-after mat-elevation-z4 mat-tab-header-pagination-disabled"><div class="mat-tab-header-pagination-chevron"></div></div></nav><div class="docs-component-viewer-content"><router-outlet></router-outlet><component-overview class="ng-star-inserted"><h2 tabindex="-1" class="cdk-visually-hidden ng-star-inserted"> test-harnesses 概览 </h2><doc-viewer class="docs-component-view-text-content docs-component-overview ng-star-inserted"><div class="docs-markdown"><p translation-result="on"><code>@angular/cdk/testing</code> 提供了一些帮助测试 Angular 组件的基础设施。</p><p translation-origin="off"><code>@angular/cdk/testing</code> provides infrastructure to help with testing Angular components.</p>


        <h3 id="component-test-harnesses" class="docs-header-link" translation-result="on">
          <span header-link="组件测试工具"><header-link class="ng-star-inserted"><a aria-label="Link to this heading" class="docs-markdown-a" href="/cdk/test-harnesses/overview#组件测试工具" aria-describedby="组件测试工具"><mat-icon role="img" class="mat-icon notranslate material-icons mat-icon-no-color" aria-hidden="true" data-mat-icon-type="font">link</mat-icon></a></header-link></span>
          组件测试工具
        </h3><h3 class="docs-header-link" translation-origin="off">
          <span header-link="component-test-harnesses"><header-link class="ng-star-inserted"><a aria-label="Link to this heading" class="docs-markdown-a" href="/cdk/test-harnesses/overview#component-test-harnesses" aria-describedby="component-test-harnesses"><mat-icon role="img" class="mat-icon notranslate material-icons mat-icon-no-color" aria-hidden="true" data-mat-icon-type="font">link</mat-icon></a></header-link></span>
          Component test harnesses
        </h3>
      
        
      <p translation-result="on">组件测试工具类是一个让测试可以通过其支持的 API 与组件交互的类。每个工具的 API 都会以和用户相同的方式与一个组件进行交互。通过使用测试工具 API，测试可以防止对组件内部的更新，比如改变它的 DOM 结构。组件测试工具的思想来自常用于集成测试的<a href="https://martinfowler.com/bliki/PageObject.html"> PageObject </a>模式。</p><p translation-origin="off">A component harness is a class that lets a test interact with a component via a supported API.
Each harness's API interacts with a component the same way a user would. By using the harness API,
a test insulates itself against updates to the internals of a component, such as changing its DOM
structure. The idea for component harnesses comes from the
<a href="https://martinfowler.com/bliki/PageObject.html">PageObject</a> pattern commonly used for integration
testing.</p>

<p translation-result="on"><code>@angular/cdk/testing</code> 包含用于创建和使用组件测试工具的基础设施。你可以为任何组件创建测试工具，范围从很小的可复用组件到完整的应用页面。</p><p translation-origin="off"><code>@angular/cdk/testing</code> contains infrastructure for creating and using component test harnesses. You
can create test harnesses for any component, ranging from small reusable widgets to full application
pages.</p>

<p translation-result="on">组件工具体系支持多种测试环境。你可以在单元测试和端到端测试中使用相同的工具实现。这意味着用户只需要学习一个 API，而组件作者不需要维护单独的单元测试和端到端测试实现。</p><p translation-origin="off">The component harness system supports multiple testing environments. You can use the same harness
implementation in both unit and end-to-end tests. This means that users only need to learn one API,
and component authors don't have to maintain separate unit and end-to-end test implementations.</p>

<p translation-result="on">特别是对于通用组件库，由于其组件的广泛使用，更容易从这种基础设施中受益。提供一个测试工具可以让组件的使用者编写一些不用依赖任何私有实现细节的测试。通过在一个地方捕获这些实现细节，消费者可以更轻松地更新到库的最新版本。</p><p translation-origin="off">Common component libraries, in particular, benefit from this infrastructure due to the wide use of
their components. Providing a test harness allows the consumers of a component to write tests that
avoid dependencies on any private implementation details. By capturing these implementation details
in a single place, consumers can more easily update to new library versions.</p>

<p translation-result="on">本文档为三类开发人员提供了指导：</p><p translation-origin="off">This document provides guidance for three types of developers:</p>

<ol>
<li><p translation-result="on"><a href="/cdk/test-harnesses/overview#api-for-test-authors">测试的作者</a></p><p translation-origin="off"><a href="/cdk/test-harnesses/overview#api-for-test-authors">Test authors</a></p>

</li>
<li><p translation-result="on"><a href="/cdk/test-harnesses/overview#api-for-component-harness-authors">组件测试工具的作者</a></p><p translation-origin="off"><a href="/cdk/test-harnesses/overview#api-for-component-harness-authors">Component harness authors</a></p>

</li>
<li><p translation-result="on"><a href="/cdk/test-harnesses/overview#api-for-harness-environment-authors">测试工具环境的作者</a></p><p translation-origin="off"><a href="/cdk/test-harnesses/overview#api-for-harness-environment-authors">Harness environment authors</a></p>

</li>
</ol>
<p translation-result="on">由于许多开发人员只会属于这些类别之一，因此相关的 API 会在下面按开发人员类型细分成不同章节。</p><p translation-origin="off">Since many developers fall into only one of these categories, the relevant APIs are broken out by
developer type in the sections below.</p>


        <h3 id="api-for-test-authors" class="docs-header-link" translation-result="on">
          <span header-link="给测试作者的-api"><header-link class="ng-star-inserted"><a aria-label="Link to this heading" class="docs-markdown-a" href="/cdk/test-harnesses/overview#给测试作者的-api" aria-describedby="给测试作者的-api"><mat-icon role="img" class="mat-icon notranslate material-icons mat-icon-no-color" aria-hidden="true" data-mat-icon-type="font">link</mat-icon></a></header-link></span>
          给测试作者的 API
        </h3><h3 class="docs-header-link" translation-origin="off">
          <span header-link="api-for-test-authors"><header-link class="ng-star-inserted"><a aria-label="Link to this heading" class="docs-markdown-a" href="/cdk/test-harnesses/overview#api-for-test-authors" aria-describedby="api-for-test-authors"><mat-icon role="img" class="mat-icon notranslate material-icons mat-icon-no-color" aria-hidden="true" data-mat-icon-type="font">link</mat-icon></a></header-link></span>
          API for test authors
        </h3>
      
        
      <p translation-result="on">测试作者就是开发人员，他们使用别人编写的组件测试工具来测试自己的应用。例如，这可能是一个使用第三方菜单组件的应用开发者，需要在单元测试中与该菜单进行交互。</p><p translation-origin="off">Test authors are developers using component harnesses written by someone else to test their
application. For example, this could be an app developer who uses a third-party menu component and
needs to interact with the menu in a unit test.</p>


        <h4 id="working-with-componentharness-classes" class="docs-header-link" translation-result="on">
          <span header-link="使用-componentharness-类"><header-link class="ng-star-inserted"><a aria-label="Link to this heading" class="docs-markdown-a" href="/cdk/test-harnesses/overview#使用-componentharness-类" aria-describedby="使用-componentharness-类"><mat-icon role="img" class="mat-icon notranslate material-icons mat-icon-no-color" aria-hidden="true" data-mat-icon-type="font">link</mat-icon></a></header-link></span>
          使用 <code>ComponentHarness</code> 类
        </h4><h4 class="docs-header-link" translation-origin="off">
          <span header-link="working-with-componentharness-classes"><header-link class="ng-star-inserted"><a aria-label="Link to this heading" class="docs-markdown-a" href="/cdk/test-harnesses/overview#working-with-componentharness-classes" aria-describedby="working-with-componentharness-classes"><mat-icon role="img" class="mat-icon notranslate material-icons mat-icon-no-color" aria-hidden="true" data-mat-icon-type="font">link</mat-icon></a></header-link></span>
          Working with <code>ComponentHarness</code> classes
        </h4>
      
        
      <p translation-result="on"><code>ComponentHarness</code> 是所有组件测试工具的抽象基类。每个测试工具都会扩展这个类。
所有 <code>ComponentHarness</code> 的子类都有一个静态属性 <code>hostSelector</code>，它把测试工具类与 DOM 中组件的实例相匹配。
除此之外，任何特定测试工具的 API 都是专属于其对应组件的。请参阅该组件的文档，了解如何使用特定的测试工具。</p><p translation-origin="off"><code>ComponentHarness</code> is the abstract base class for all component harnesses. Every harness extends
this class. All <code>ComponentHarness</code> subclasses have a static property, <code>hostSelector</code>, that
matches the harness class to instances of the component in the DOM. Beyond that, the API of any
given harness is specific to its corresponding component; refer to the component's documentation to
learn how to use a specific harness.</p>


        <h4 id="using-testbedharnessenvironment-and-protractorharnessenvironment" class="docs-header-link" translation-result="on">
          <span header-link="使用-testbedharnessenvironment-和-protractorharnessenvironment"><header-link class="ng-star-inserted"><a aria-label="Link to this heading" class="docs-markdown-a" href="/cdk/test-harnesses/overview#使用-testbedharnessenvironment-和-protractorharnessenvironment" aria-describedby="使用-testbedharnessenvironment-和-protractorharnessenvironment"><mat-icon role="img" class="mat-icon notranslate material-icons mat-icon-no-color" aria-hidden="true" data-mat-icon-type="font">link</mat-icon></a></header-link></span>
          使用 <code>TestbedHarnessEnvironment</code> 和 <code>ProtractorHarnessEnvironment</code>
        </h4><h4 class="docs-header-link" translation-origin="off">
          <span header-link="using-testbedharnessenvironment-and-protractorharnessenvironment"><header-link class="ng-star-inserted"><a aria-label="Link to this heading" class="docs-markdown-a" href="/cdk/test-harnesses/overview#using-testbedharnessenvironment-and-protractorharnessenvironment" aria-describedby="using-testbedharnessenvironment-and-protractorharnessenvironment"><mat-icon role="img" class="mat-icon notranslate material-icons mat-icon-no-color" aria-hidden="true" data-mat-icon-type="font">link</mat-icon></a></header-link></span>
          Using <code>TestbedHarnessEnvironment</code> and <code>ProtractorHarnessEnvironment</code>
        </h4>
      
        
      <p translation-result="on">这些类对应于组件工具体系的不同实现，并绑定到特定的测试环境。任何一种测试都只能导入<em>其中一个</em>类。
基于 Karma 的单元测试应该使用 <code>TestbedHarnessEnvironment</code>，而基于 Protractor 的端到端测试应该使用 <code>ProtractorHarnessEnvironment</code>。
其他环境会要求自定义绑定；给参见<a href="/cdk/test-harnesses/overview#api-for-harness-environment-authors">测试工具环境作者的 API</a>，以了解有关备用测试环境的更多信息。</p><p translation-origin="off">These classes correspond to different implementations of the component harness system with bindings
for specific test environments. Any given test must only import <em>one</em> of these classes. Karma-based
unit tests should use the <code>TestbedHarnessEnvironment</code>, while Protractor-based end-to-end tests
should use the <code>ProtractorHarnessEnvironment</code>. Additional environments require custom bindings; see
<a href="/cdk/test-harnesses/overview#api-for-harness-environment-authors">API for harness environment authors</a> for more information on
alternate test environments.</p>

<p translation-result="on">这些类主要用于创建一个 <code>HarnessLoader</code> 实例，在某些情况下，还可以用来创建 <code>ComponentHarness</code> 实例。</p><p translation-origin="off">These classes are primarily used to create a <code>HarnessLoader</code> instance, and in certain cases, to
create <code>ComponentHarness</code> instances directly.</p>

<p translation-result="on"><code>TestbedHarnessEnvironment</code> 提供了以下静态方法：</p><p translation-origin="off"><code>TestbedHarnessEnvironment</code> offers the following static methods:</p>

<table>
<thead>
<tr>
<th><p translation-result="on">方法</p><p translation-origin="off">Method</p></th>
<th><p translation-result="on">说明</p><p translation-origin="off">Description</p></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>loader(fixture: ComponentFixture&lt;unknown&gt;): HarnessLoader</code></td>
<td><p translation-result="on">获取 <code>HarnessLoader</code> 实例，该实例以测试夹具的根元素为根。用来为夹具里面的元素创建测试工具</p><p translation-origin="off">Gets a <code>HarnessLoader</code> instance for the given fixture, rooted at the fixture's root element. Should be used to create harnesses for elements contained inside the fixture</p></td>
</tr>

<tr>
<td><code>documentRootLoader(fixture: ComponentFixture&lt;unknown&gt;): HarnessLoader</code></td>
<td><p translation-result="on">获取 <code>HarnessLoader</code> 实例，该实例以 HTML 文档的根元素为根。可以用来为那些夹具外面的元素创建测试工具</p><p translation-origin="off">Gets a <code>HarnessLoader</code> instance for the given fixture, rooted at the HTML document's root element. Can be used to create harnesses for elements that fall outside of the fixture</p></td>
</tr>

<tr>
<td><code>harnessForFixture&lt;T extends ComponentHarness&gt;(fixture: ComponentFixture&lt;unknown&gt;, harnessType: ComponentHarnessConstructor&lt;T&gt;): Promise&lt;T&gt;</code></td>
<td><p translation-result="on">用来直接为夹具的根元素创建一个 <code>ComponentHarness</code>。当使用你计划为其加载测试工具的组件启动测试时，这是必要的，因为在创建夹具时，Angular 还没有设置正确的标签名。</p><p translation-origin="off">Used to create a <code>ComponentHarness</code> instance for the fixture's root element directly. This is necessary when bootstrapping the test with the component you plan to load a harness for, because Angular does not set the proper tag name when creating the fixture.</p></td>
</tr>

</tbody></table>
<p translation-result="on">在大多数情况下，你可以使用 <code>TestbedHarnessEnvironment.loader(fixture)</code> 在 <code>beforeEach</code> 中创建一个 <code>HarnessLoader</code>，然后使用该 <code>HarnessLoader</code> 来创建任何必要的 <code>ComponentHarness</code> 实例。其他方法涵盖了那些特例，如下例所示：</p><p translation-origin="off">In most cases, you can create a <code>HarnessLoader</code> in the <code>beforeEach</code> block using
<code>TestbedHarnessEnvironment.loader(fixture)</code> and then use that <code>HarnessLoader</code> to create any
necessary <code>ComponentHarness</code> instances. The other methods cover special cases as shown in this
example:</p>

<p translation-result="on">考虑一个可复用的对话框按钮组件，它在单击时会打开一个对话框，其中包含以下组件，每个组件都带有相应的工具：</p><p translation-origin="off">Consider a reusable dialog-button component that opens a dialog on click, containing the following
components, each with a corresponding harness:</p>

<ul>
<li><p translation-result="on"><code>MyDialogButton</code>（用便利 API 组合 <code>MyButton</code> 与 <code>MyDialog</code>）</p><p translation-origin="off"><code>MyDialogButton</code> (composes the <code>MyButton</code> and <code>MyDialog</code> with a convenient API)</p>

</li>
<li><p translation-result="on"><code>MyButton</code> （简单按钮组件）</p><p translation-origin="off"><code>MyButton</code> (a simple button component)</p>

</li>
<li><p translation-result="on"><code>MyDialog</code> （通过点击 <code>MyDialogButton</code>，把一个对话框附着到 <code>document.body</code> 上）</p><p translation-origin="off"><code>MyDialog</code> (a dialog appended to <code>document.body</code> by <code>MyDialogButton</code> upon click)</p>

</li>
</ul>
<p translation-result="on">下列代码为每个组件加载了一些测试工具：</p><p translation-origin="off">The following code loads harnesses for each of these components:</p>

<pre><code class="language-ts"><span class="hljs-keyword">let</span> fixture: ComponentFixture&lt;MyDialogButton&gt;;
<span class="hljs-keyword">let</span> loader: HarnessLoader;
<span class="hljs-keyword">let</span> rootLoader: HarnessLoader;

beforeEach(<span class="hljs-function">() =&gt;</span> {
  fixture = TestBed.createComponent(MyDialogButton);
  loader = TestbedHarnessEnvironment.loader(fixture);
  rootLoader = TestbedHarnessEnvironment.documentRootLoader(fixture);
});

it(<span class="hljs-string">'loads harnesses'</span>, <span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-comment">// Load a harness for the bootstrapped component with `harnessForFixture`</span>
  dialogButtonHarness =
      <span class="hljs-keyword">await</span> TestbedHarnessEnvironment.harnessForFixture(fixture, MyDialogButtonHarness);

  <span class="hljs-comment">// The button element is inside the fixture's root element, so we use `loader`.</span>
  <span class="hljs-keyword">const</span> buttonHarness = <span class="hljs-keyword">await</span> loader.getHarness(MyButtonHarness);

  <span class="hljs-comment">// Click the button to open the dialog</span>
  <span class="hljs-keyword">await</span> buttonHarness.click();

  <span class="hljs-comment">// The dialog is appended to `document.body`, outside of the fixture's root element,</span>
  <span class="hljs-comment">// so we use `rootLoader` in this case.</span>
  <span class="hljs-keyword">const</span> dialogHarness = <span class="hljs-keyword">await</span> rootLoader.getHarness(MyDialogHarness);

  <span class="hljs-comment">// ... make some assertions</span>
});
</code></pre>
<p translation-result="on"><code>ProtractorHarnessEnvironment</code> 有一个提供单个静态方法的 API：</p><p translation-origin="off"><code>ProtractorHarnessEnvironment</code> has an API that offers a single static method:</p>

<table>
<thead>
<tr>
<th><p translation-result="on">方法</p><p translation-origin="off">Method</p></th>
<th><p translation-result="on">说明</p><p translation-origin="off">Description</p></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>loader(): HarnessLoader</code></td>
<td><p translation-result="on">获取 <code>HarnessLoader</code> 实例，该实例以该文档的根元素为根。</p><p translation-origin="off">Gets a <code>HarnessLoader</code> instance for the current HTML document, rooted at the document's root element.</p></td>
</tr>

</tbody></table>
<p translation-result="on">虽然 Protractor 不知道怎么用夹具，但这个环境下的 API 比较简单。<code>loader()</code> 方法返回的 <code>HarnessLoader</code> 应足以加载所有必需的 <code>ComponentHarness</code> 实例。</p><p translation-origin="off">Since Protractor does not deal with fixtures, the API in this environment is simpler. The
<code>HarnessLoader</code> returned by the <code>loader()</code> method should be sufficient for loading all necessary
<code>ComponentHarness</code> instances.</p>

<p translation-result="on">请注意，在各种环境中，测试工具的行为可能并不<em>完全相同</em>。当用户点击或输入某个元素时，真正的浏览器生成的事件序列与单元测试中生成的模拟事件序列之间总有一些区别。不过，CDK 会尽最大努力规范其行为，并模拟序列中最重要的事件。</p><p translation-origin="off">Please note that harnesses may not behave <em>exactly</em> the same in all environments. There will always
be some difference between the real browser-generated event sequence when a user clicks or types in
an element, versus the simulated event sequence generated in unit tests. Instead, the CDK makes a
best effort to normalize the behavior and simulate the most important events in the sequence.</p>


        <h4 id="creating-harnesses-with-harnessloader" class="docs-header-link" translation-result="on">
          <span header-link="使用-harnessloader-创建测试工具"><header-link class="ng-star-inserted"><a aria-label="Link to this heading" class="docs-markdown-a" href="/cdk/test-harnesses/overview#使用-harnessloader-创建测试工具" aria-describedby="使用-harnessloader-创建测试工具"><mat-icon role="img" class="mat-icon notranslate material-icons mat-icon-no-color" aria-hidden="true" data-mat-icon-type="font">link</mat-icon></a></header-link></span>
          使用 <code>HarnessLoader</code> 创建测试工具
        </h4><h4 class="docs-header-link" translation-origin="off">
          <span header-link="creating-harnesses-with-harnessloader"><header-link class="ng-star-inserted"><a aria-label="Link to this heading" class="docs-markdown-a" href="/cdk/test-harnesses/overview#creating-harnesses-with-harnessloader" aria-describedby="creating-harnesses-with-harnessloader"><mat-icon role="img" class="mat-icon notranslate material-icons mat-icon-no-color" aria-hidden="true" data-mat-icon-type="font">link</mat-icon></a></header-link></span>
          Creating harnesses with <code>HarnessLoader</code>
        </h4>
      
        
      <p translation-result="on">该类的实例对应一个特定的 DOM 元素（此加载器的“根元素”），用于为该根元素下的元素创建 <code>ComponentHarness</code>。</p><p translation-origin="off">Instances of this class correspond to a specific DOM element (the "root element" of the loader) and
are used to create <code>ComponentHarness</code> instances for elements under this root element.</p>

<p translation-result="on"><code>HarnessLoader</code> 实例有以下几种方法：</p><p translation-origin="off"><code>HarnessLoader</code> instances have the following methods:</p>

<table>
<thead>
<tr>
<th><p translation-result="on">方法</p><p translation-origin="off">Method</p></th>
<th><p translation-result="on">说明</p><p translation-origin="off">Description</p></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>getChildLoader(selector: string): Promise&lt;HarnessLoader&gt;</code></td>
<td><p translation-result="on">在 <code>HarnessLoader</code> 的根元素下搜索匹配指定选择器的元素，并返回以第一个匹配元素为根的 <code>HarnessLoader</code></p><p translation-origin="off">Searches for an element matching the given selector below the root element of this <code>HarnessLoader</code>, and returns a new <code>HarnessLoader</code> rooted at the first matching element</p></td>
</tr>

<tr>
<td><code>getAllChildLoaders(selector: string): Promise&lt;HarnessLoader[]&gt;</code></td>
<td><p translation-result="on">行为类似于 <code>getChildLoader</code>，但返回一个 HarnessLoader 实例数组，给每个匹配的元素一个实例，而不是只给第一个匹配的元素</p><p translation-origin="off">Acts like <code>getChildLoader</code>, but returns an array of <code>HarnessLoader</code> instances, one for each matching element, rather than just the first matching element</p></td>
</tr>

<tr>
<td><code>getHarness&lt;T extends ComponentHarness&gt;(harnessType: ComponentHarnessConstructor&lt;T&gt; | HarnessPredicate&lt;T&gt;): Promise&lt;T&gt;</code></td>
<td><p translation-result="on">在 <code>HarnessLoader</code> 的根元素下面搜索指定的 <code>ComponentHarness</code> 或 <code>HarnessPredicate</code> 类的实例，并返回与第一个匹配元素对应的测试工具的实例</p><p translation-origin="off">Searches for an instance of the given <code>ComponentHarness</code> class or <code>HarnessPredicate</code> below the root element of this <code>HarnessLoader</code> and returns an instance of the harness corresponding to the first matching element</p></td>
</tr>

<tr>
<td><code>getAllHarnesses&lt;T extends ComponentHarness&gt;(harnessType: ComponentHarnessConstructor&lt;T&gt; | HarnessPredicate&lt;T&gt;): Promise&lt;T[]&gt;</code></td>
<td><p translation-result="on">行为类似于 <code>getHarness</code>，但会返回一个测试工具实例的数组，给每个匹配的元素一个实例，而不只是只给第一个匹配的元素</p><p translation-origin="off">Acts like <code>getHarness</code>, but returns an array of harness instances, one for each matching element, rather than just the first matching element</p></td>
</tr>

</tbody></table>
<p translation-result="on">调用 <code>getHarness</code> 和 <code>getAllHarnesses</code> 的参数可以是 <code>ComponentHarness</code> 的子类或 <code>HarnessPredicate</code>。<code>HarnessPredicate</code> 对搜索应用了额外的限制（比如搜索一些带有特定文本的按钮等）。<a href="/cdk/test-harnesses/overview#filtering-harness-instances-with-harnesspredicate"><code>HarnessPredicate</code></a> 的<a href="/cdk/test-harnesses/overview#filtering-harness-instances-with-harnesspredicate">详细信息</a>在<a href="/cdk/test-harnesses/overview#api-for-component-harness-authors">组件工具作者</a>的 API 部分讨论。组件工具的作者应该在 <code>ComponentHarness</code> 子类中提供了一些创建 <code>HarnessPredicate</code> 实例的便利方法。但是，如果测试工具作者提供的 API 不够用，你也可以手动创建它们。</p><p translation-origin="off">Calls to <code>getHarness</code> and <code>getAllHarnesses</code> can either take <code>ComponentHarness</code> subclass or a
<code>HarnessPredicate</code>. <code>HarnessPredicate</code> applies additional restrictions to the search (e.g. searching
for a button that has some particular text, etc). The
<a href="/cdk/test-harnesses/overview#filtering-harness-instances-with-harnesspredicate">details of <code>HarnessPredicate</code></a> are discussed in
the <a href="/cdk/test-harnesses/overview#api-for-component-harness-authors">API for component harness authors</a>; harness authors should
provide convenience methods on their <code>ComponentHarness</code> subclass to facilitate the creation of
<code>HarnessPredicate</code> instances. However, if the harness author's API is not sufficient, they can be
created manually.</p>


        <h4 id="change-detection" class="docs-header-link" translation-result="on">
          <span header-link="变更检测"><header-link class="ng-star-inserted"><a aria-label="Link to this heading" class="docs-markdown-a" href="/cdk/test-harnesses/overview#变更检测" aria-describedby="变更检测"><mat-icon role="img" class="mat-icon notranslate material-icons mat-icon-no-color" aria-hidden="true" data-mat-icon-type="font">link</mat-icon></a></header-link></span>
          变更检测
        </h4><h4 class="docs-header-link" translation-origin="off">
          <span header-link="change-detection"><header-link class="ng-star-inserted"><a aria-label="Link to this heading" class="docs-markdown-a" href="/cdk/test-harnesses/overview#change-detection" aria-describedby="change-detection"><mat-icon role="img" class="mat-icon notranslate material-icons mat-icon-no-color" aria-hidden="true" data-mat-icon-type="font">link</mat-icon></a></header-link></span>
          Change detection
        </h4>
      
        
      <p translation-result="on">默认情况下，测试工具会在读取 DOM 元素的状态之前和与 DOM 元素交互之后运行 Angular 变更检测。这虽然在大多数情况下很方便，但有时候你需要对变更检测进行更细粒度的控制。例如，你可能希望在异步操作挂起时检查某个组件的状态。在这些情况下，你可以使用 <code>manualChangeDetection</code> 函数来禁用对代码块的自动变更检测。例如：</p><p translation-origin="off">By default, test harnesses will run Angular's change detection before reading the state of a DOM
element and after interacting with a DOM element. While convenient in most cases, there may be times
that you need finer-grained control over change detection. For example, you may want to check the
state of a component while an async operation is pending. In these cases you can use the
<code>manualChangeDetection</code> function to disable automatic handling of change detection for a block of
code. For example:</p>

<pre><code class="language-ts">it(<span class="hljs-string">'checks state while async action is in progress'</span>, <span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">const</span> buttonHarness = loader.getHarness(MyButtonHarness);
  <span class="hljs-keyword">await</span> manualChangeDetection(<span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">await</span> buttonHarness.click();
    fixture.detectChanges();
    <span class="hljs-comment">// Check expectations while async click operation is in progress.</span>
    expect(isProgressSpinnerVisible()).toBe(<span class="hljs-literal">true</span>);
    <span class="hljs-keyword">await</span> fixture.whenStable();
    <span class="hljs-comment">// Check expectations after async click operation complete.</span>
    expect(isProgressSpinnerVisible()).toBe(<span class="hljs-literal">false</span>);
  });
});
</code></pre>

        <h4 id="working-with-asynchronous-component-harness-methods" class="docs-header-link" translation-result="on">
          <span header-link="使用组件测试工具的异步方法"><header-link class="ng-star-inserted"><a aria-label="Link to this heading" class="docs-markdown-a" href="/cdk/test-harnesses/overview#使用组件测试工具的异步方法" aria-describedby="使用组件测试工具的异步方法"><mat-icon role="img" class="mat-icon notranslate material-icons mat-icon-no-color" aria-hidden="true" data-mat-icon-type="font">link</mat-icon></a></header-link></span>
          使用组件测试工具的异步方法
        </h4><h4 class="docs-header-link" translation-origin="off">
          <span header-link="working-with-asynchronous-component-harness-methods"><header-link class="ng-star-inserted"><a aria-label="Link to this heading" class="docs-markdown-a" href="/cdk/test-harnesses/overview#working-with-asynchronous-component-harness-methods" aria-describedby="working-with-asynchronous-component-harness-methods"><mat-icon role="img" class="mat-icon notranslate material-icons mat-icon-no-color" aria-hidden="true" data-mat-icon-type="font">link</mat-icon></a></header-link></span>
          Working with asynchronous component harness methods
        </h4>
      
        
      <p translation-result="on">为了支持单元测试和端到端测试，并把测试与异步行为的变化隔离开来，测试工具几乎的所有方法都是异步的，并返回一个 <code>Promise</code>；因此，Angular 团队建议使用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function">ES2017 的 <code>async</code> / <code>await</code> 语法</a>来提高测试的可读性。</p><p translation-origin="off">To support both unit and end-to-end tests, and to insulate tests against changes in
asynchronous behavior, almost all harness methods are asynchronous and return a <code>Promise</code>;
therefore, the Angular team recommends using
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function">ES2017 <code>async</code>/<code>await</code> syntax</a>
to improve the test readability.</p>

<p translation-result="on">注意，<code>await</code> 语句会阻塞测试的执行，直到相关的 <code>Promise</code> 被解析为止。有时，你可能希望同时执行多个动作，并等待它们全部完成，而不是按顺序执行每个动作。例如，从单个组件中读取多个属性。在这种情况下，请使用 <code>parallel</code> 函数来并行处理这些操作。parallel 函数与 <code>Promise.all</code> 工作方式类似，但同时优化了变更检测，因此它的运行次数不会太多。以下代码演示如何通过 <code>parallel</code> 从测试工具中读取多个属性：</p><p translation-origin="off">Note that <code>await</code> statements block the execution of your test until the associated <code>Promise</code>
resolves. Occasionally, you may want to perform multiple actions simultaneously and wait until
they're all done rather than performing each action sequentially. For example, reading multiple
properties off a single component. In these situations use the <code>parallel</code> function to parallelize
the operations. The parallel function works similarly to <code>Promise.all</code>, while also optimizing change
detection, so it is not run an excessive number of times. The following code demonstrates how you
can read multiple properties from a harness with <code>parallel</code>:</p>

<pre><code class="language-ts">it(<span class="hljs-string">'reads properties in parallel'</span>, <span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">const</span> checkboxHarness = loader.getHarness(MyCheckboxHarness);
  <span class="hljs-comment">// Read the checked and intermediate properties simultaneously.</span>
  <span class="hljs-keyword">const</span> [checked, indeterminate] = <span class="hljs-keyword">await</span> parallel(<span class="hljs-function">() =&gt;</span> [
    checkboxHarness.isChecked(),
    checkboxHarness.isIndeterminate()
  ]);
  expect(checked).toBe(<span class="hljs-literal">false</span>);
  expect(indeterminate).toBe(<span class="hljs-literal">true</span>);
});
</code></pre>

        <h3 id="api-for-component-harness-authors" class="docs-header-link" translation-result="on">
          <span header-link="组件测试工具作者的-api"><header-link class="ng-star-inserted"><a aria-label="Link to this heading" class="docs-markdown-a" href="/cdk/test-harnesses/overview#组件测试工具作者的-api" aria-describedby="组件测试工具作者的-api"><mat-icon role="img" class="mat-icon notranslate material-icons mat-icon-no-color" aria-hidden="true" data-mat-icon-type="font">link</mat-icon></a></header-link></span>
          组件测试工具作者的 API
        </h3><h3 class="docs-header-link" translation-origin="off">
          <span header-link="api-for-component-harness-authors"><header-link class="ng-star-inserted"><a aria-label="Link to this heading" class="docs-markdown-a" href="/cdk/test-harnesses/overview#api-for-component-harness-authors" aria-describedby="api-for-component-harness-authors"><mat-icon role="img" class="mat-icon notranslate material-icons mat-icon-no-color" aria-hidden="true" data-mat-icon-type="font">link</mat-icon></a></header-link></span>
          API for component harness authors
        </h3>
      
        
      <p translation-result="on">组件测试工具作者是那些需要维护一些可复用的 Angular 组件并希望为它创建一个测试工具的开发人员，组件用户可以在测试中使用它。
例如，可能是第三方 Angular 组件库的作者，也可能是为大型 Angular 应用维护一组通用组件的开发人员。</p><p translation-origin="off">Component harness authors are developers who maintain some reusable Angular component, and want to
create a test harness for it, that users of the component can use in their tests. For example, this
could be an author of a third party Angular component library or a developer who maintains a set of
common components for a large Angular application.</p>


        <h4 id="extending-componentharness" class="docs-header-link" translation-result="on">
          <span header-link="扩展-componentharness"><header-link class="ng-star-inserted"><a aria-label="Link to this heading" class="docs-markdown-a" href="/cdk/test-harnesses/overview#扩展-componentharness" aria-describedby="扩展-componentharness"><mat-icon role="img" class="mat-icon notranslate material-icons mat-icon-no-color" aria-hidden="true" data-mat-icon-type="font">link</mat-icon></a></header-link></span>
          扩展 <code>ComponentHarness</code>
        </h4><h4 class="docs-header-link" translation-origin="off">
          <span header-link="extending-componentharness"><header-link class="ng-star-inserted"><a aria-label="Link to this heading" class="docs-markdown-a" href="/cdk/test-harnesses/overview#extending-componentharness" aria-describedby="extending-componentharness"><mat-icon role="img" class="mat-icon notranslate material-icons mat-icon-no-color" aria-hidden="true" data-mat-icon-type="font">link</mat-icon></a></header-link></span>
          Extending <code>ComponentHarness</code>
        </h4>
      
        
      <p translation-result="on">抽象类 <code>ComponentHarness</code> 是所有组件测试工具的基类。要创建自定义组件测试工具，请扩展 <code>ComponentHarness</code> 并实现其静态属性 <code>hostSelector</code>。<code>hostSelector</code> 属性用于标识 DOM 中与该测试工具子类相匹配的元素。在大多数情况下，<code>hostSelector</code> 应该与相应的 <code>Component</code> 或 <code>Directive</code> 的 <code>selector</code> 相同。例如，考虑一个简单的弹出框组件：</p><p translation-origin="off">The abstract <code>ComponentHarness</code> class is the base class for all component harnesses. To create a
custom component harness, extend <code>ComponentHarness</code> and implement the static property
<code>hostSelector</code>. The <code>hostSelector</code> property identifies elements in the DOM that match this harness
subclass. In most cases, the <code>hostSelector</code> should be the same as the <code>selector</code> of the corresponding
<code>Component</code> or <code>Directive</code>. For example, consider a simple popup component:</p>

<pre><code class="language-ts"><span class="hljs-meta">@Component</span>({
  <span class="hljs-attr">selector</span>: <span class="hljs-string">'my-popup'</span>,
  <span class="hljs-attr">template</span>: <span class="hljs-string">`
    &lt;button (click)="toggle()"&gt;{{triggerText}}&lt;/button&gt;
    &lt;div *ngIf="open" class="my-popup-content"&gt;&lt;ng-content&gt;&lt;/ng-content&gt;&lt;/div&gt;
  `</span>
})
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPopup</span> </span>{
  <span class="hljs-meta">@Input</span>() triggerText: <span class="hljs-built_in">string</span>;

  open = <span class="hljs-literal">false</span>;

  <span class="hljs-function"><span class="hljs-title">toggle</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-built_in">this</span>.open = !<span class="hljs-built_in">this</span>.open;
  }
}
</code></pre>
<p translation-result="on">在这种情况下，该组件的最简测试工具如下所示：</p><p translation-origin="off">In this case, a minimal harness for the component would look like the following:</p>

<pre><code class="language-ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPopupHarness</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ComponentHarness</span> </span>{
  <span class="hljs-keyword">static</span> hostSelector = <span class="hljs-string">'my-popup'</span>;
}
</code></pre>
<p translation-result="on">虽然 <code>ComponentHarness</code> 子类只需要 <code>hostSelector</code> 属性，但大多数测试工具还应该使用静态方法 <code>with</code> 来生成 <code>HarnessPredicate</code> 实例。下面的 <a href="/cdk/test-harnesses/overview#filtering-harness-instances-with-harnesspredicate"><code>HarnessPredicate</code></a> 部分会更详细介绍这一点。</p><p translation-origin="off">While <code>ComponentHarness</code> subclasses require only the <code>hostSelector</code> property, most harnesses should
also implement a static <code>with</code> method to generate <code>HarnessPredicate</code> instances. The
<a href="/cdk/test-harnesses/overview#filtering-harness-instances-with-harnesspredicate"><code>HarnessPredicate</code></a> section below covers this
in more detail.</p>


        <h4 id="finding-elements-in-the-components-dom" class="docs-header-link" translation-result="on">
          <span header-link="在组件的-dom-中查找元素"><header-link class="ng-star-inserted"><a aria-label="Link to this heading" class="docs-markdown-a" href="/cdk/test-harnesses/overview#在组件的-dom-中查找元素" aria-describedby="在组件的-dom-中查找元素"><mat-icon role="img" class="mat-icon notranslate material-icons mat-icon-no-color" aria-hidden="true" data-mat-icon-type="font">link</mat-icon></a></header-link></span>
          在组件的 DOM 中查找元素
        </h4><h4 class="docs-header-link" translation-origin="off">
          <span header-link="finding-elements-in-the-components-dom"><header-link class="ng-star-inserted"><a aria-label="Link to this heading" class="docs-markdown-a" href="/cdk/test-harnesses/overview#finding-elements-in-the-components-dom" aria-describedby="finding-elements-in-the-components-dom"><mat-icon role="img" class="mat-icon notranslate material-icons mat-icon-no-color" aria-hidden="true" data-mat-icon-type="font">link</mat-icon></a></header-link></span>
          Finding elements in the component's DOM
        </h4>
      
        
      <p translation-result="on"><code>ComponentHarness</code> 子类的每个实例都表示相应组件的一个特定实例。你可以用 <code>ComponentHarness</code> 类的 <code>host</code> 方法访问组件的宿主元素。</p><p translation-origin="off">Each instance of a <code>ComponentHarness</code> subclass represents a particular instance of the
corresponding component. You can access the component's host element via the <code>host</code> method from
the <code>ComponentHarness</code> base class.</p>

<p translation-result="on"><code>ComponentHarness</code> 还提供了几种在组件 DOM 中定位元素的方法。它们是 <code>locatorFor</code>、<code>locatorForOptional</code> 和 <code>locatorForAll</code>。但请注意，这些方法并不直接查找元素，而是会<em>创建</em>能寻找元素的函数。这种方式可以防止缓存对过时元素的引用。例如，当一个 <code>ngIf</code> 先隐藏再显示一个元素时，其结果是一个新的 DOM 元素；使用函数可以确保测试总能引用 DOM 的当前状态。</p><p translation-origin="off"><code>ComponentHarness</code> additionally offers several methods for locating elements within the component's
DOM. These methods are <code>locatorFor</code>, <code>locatorForOptional</code>, and <code>locatorForAll</code>.
Note, though, that these methods do not directly find elements. Instead, they <em>create functions</em>
that find elements. This approach safeguards against caching references to out-of-date elements. For
example, when an <code>ngIf</code> hides and then shows an element, the result is a new DOM element; using
functions ensures that tests always reference the current state of the DOM.</p>

<table>
<thead>
<tr>
<th><p translation-result="on">方法</p><p translation-origin="off">Method</p></th>
<th><p translation-result="on">说明</p><p translation-origin="off">Description</p></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>host(): Promise&lt;TestElement&gt;</code></td>
<td><p translation-result="on">返回相应组件实例的宿主元素的 <code>Promise</code></p><p translation-origin="off">Returns a <code>Promise</code> for the host element of the corresponding component instance.</p></td>
</tr>

<tr>
<td><code>locatorFor(selector: string): () =&gt; Promise&lt;TestElement&gt;</code></td>
<td><p translation-result="on">创建一个函数，该函数在被调用时会返回与指定选择器匹配的第一个元素的 <code>Promise</code>。如果找不到匹配的元素，<code>Promise</code> 就会拒绝。</p><p translation-origin="off">Creates a function that returns a <code>Promise</code> for the first element matching the given selector when called. If no matching element is found, the <code>Promise</code> rejects.</p></td>
</tr>

<tr>
<td><code>locatorForOptional(selector: string): () =&gt; Promise&lt;TestElement | null&gt;</code></td>
<td><p translation-result="on">创建一个函数，该函数在被调用时会返回与指定选择器匹配的第一个元素的 <code>Promise</code>。如果找不到匹配的元素，则会解析成携带 <code>null</code> 的 <code>Promise</code>。</p><p translation-origin="off">Creates a function that returns a <code>Promise</code> for the first element matching the given selector when called. If no matching element is found, the <code>Promise</code> is resolved with <code>null</code>.</p></td>
</tr>

<tr>
<td><code>locatorForAll(selector: string): () =&gt; Promise&lt;TestElement[]&gt;</code></td>
<td><p translation-result="on">创建一个函数，它返回一个 <code>Promise</code> 以便在调用时返回与指定选择器匹配的所有元素的列表。</p><p translation-origin="off">Creates a function that returns a <code>Promise</code> for a list of all elements matching the given selector when called.</p></td>
</tr>

</tbody></table>
<p translation-result="on">例如，<code>MyPopupHarness</code> 类可以提供获取触发器和内容元素的方法，如下所示：</p><p translation-origin="off">For example, the <code>MyPopupHarness</code> class discussed above could provide methods to get the trigger
and content elements as follows:</p>

<pre><code class="language-ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPopupHarness</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ComponentHarness</span> </span>{
  <span class="hljs-keyword">static</span> hostSelector = <span class="hljs-string">'my-popup'</span>;

  <span class="hljs-comment">/** Gets the trigger element */</span>
  getTriggerElement = <span class="hljs-built_in">this</span>.locatorFor(<span class="hljs-string">'button'</span>);

  <span class="hljs-comment">/** Gets the content element. */</span>
  getContentElement = <span class="hljs-built_in">this</span>.locatorForOptional(<span class="hljs-string">'.my-popup-content'</span>);
}
</code></pre>

        <h4 id="working-with-testelement-instances" class="docs-header-link" translation-result="on">
          <span header-link="使用-testelement-实例"><header-link class="ng-star-inserted"><a aria-label="Link to this heading" class="docs-markdown-a" href="/cdk/test-harnesses/overview#使用-testelement-实例" aria-describedby="使用-testelement-实例"><mat-icon role="img" class="mat-icon notranslate material-icons mat-icon-no-color" aria-hidden="true" data-mat-icon-type="font">link</mat-icon></a></header-link></span>
          使用 <code>TestElement</code> 实例
        </h4><h4 class="docs-header-link" translation-origin="off">
          <span header-link="working-with-testelement-instances"><header-link class="ng-star-inserted"><a aria-label="Link to this heading" class="docs-markdown-a" href="/cdk/test-harnesses/overview#working-with-testelement-instances" aria-describedby="working-with-testelement-instances"><mat-icon role="img" class="mat-icon notranslate material-icons mat-icon-no-color" aria-hidden="true" data-mat-icon-type="font">link</mat-icon></a></header-link></span>
          Working with <code>TestElement</code> instances
        </h4>
      
        
      <p translation-result="on">使用上述定位器方法创建的函数都返回了 <code>TestElement</code> 实例。<code>TestElement</code> 提供了许多与底层 DOM 交互的方法：</p><p translation-origin="off">The functions created with the locator methods described above all return <code>TestElement</code> instances.
<code>TestElement</code> offers a number of methods to interact with the underlying DOM:</p>

<table>
<thead>
<tr>
<th><p translation-result="on">方法</p><p translation-origin="off">Method</p></th>
<th><p translation-result="on">说明</p><p translation-origin="off">Description</p></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>blur(): Promise&lt;void&gt;</code></td>
<td><p translation-result="on">让此元素失焦。</p><p translation-origin="off">Blurs the element.</p></td>
</tr>

<tr>
<td><code>clear(): Promise&lt;void&gt;</code></td>
<td><p translation-result="on">清除此元素中的文本（仅适用于 <code>&lt;input&gt;</code> 和 <code>&lt;textarea&gt;</code> ）。</p><p translation-origin="off">Clears the text in the element (intended for <code>&lt;input&gt;</code> and <code>&lt;textarea&gt;</code> only).</p></td>
</tr>

<tr>
<td><code>click(relativeX?: number, relativeY?: number): Promise&lt;void&gt;</code></td>
<td><p translation-result="on">单击此元素（相对于此元素左上角的指定位置）。</p><p translation-origin="off">Clicks the element (at the given position relative to the element's top-left corner).</p></td>
</tr>

<tr>
<td><code>focus(): Promise&lt;void&gt;</code></td>
<td><p translation-result="on">让此元素获得焦点。</p><p translation-origin="off">Focuses the element.</p></td>
</tr>

<tr>
<td><code>getCssValue(property: string): Promise&lt;string&gt;</code></td>
<td><p translation-result="on">获取此元素指定 CSS 属性的计算值。</p><p translation-origin="off">Gets the computed value of the given CSS property for the element.</p></td>
</tr>

<tr>
<td><code>hover(): Promise&lt;void&gt;</code></td>
<td><p translation-result="on">悬停在此元素上方。</p><p translation-origin="off">Hovers over the element.</p></td>
</tr>

<tr>
<td><code>sendKeys(modifiers?: ModifierKeys, ...keys: (string | TestKey)[]): Promise&lt;void&gt;</code></td>
<td><p translation-result="on">给此元素发送指定的按键列表（可以带修饰键）。</p><p translation-origin="off">Sends the given list of key presses to the element (with optional modifier keys).</p></td>
</tr>

<tr>
<td><code>text(): Promise&lt;string&gt;</code></td>
<td><p translation-result="on">获取此元素的文本内容</p><p translation-origin="off">Gets the text content of the element</p></td>
</tr>

<tr>
<td><code>getAttribute(name: string): Promise&lt;string | null&gt;</code></td>
<td><p translation-result="on">从此元素获取指定的 HTML 属性的值。</p><p translation-origin="off">Gets the value of the given HTML attribute for the element.</p></td>
</tr>

<tr>
<td><code>hasClass(name: string): Promise&lt;boolean&gt;</code></td>
<td><p translation-result="on">检查此元素是否已应用了指定的类。</p><p translation-origin="off">Checks whether the element has the given class applied.</p></td>
</tr>

<tr>
<td><code>getDimensions(): Promise&lt;ElementDimensions&gt;</code></td>
<td><p translation-result="on">获取此元素的尺寸。</p><p translation-origin="off">Gets the dimensions of the element.</p></td>
</tr>

<tr>
<td><code>getProperty(name: string): Promise&lt;any&gt;</code></td>
<td><p translation-result="on">从此元素获取指定的 JS 属性的值。</p><p translation-origin="off">Gets the value of the given JS property for the element.</p></td>
</tr>

<tr>
<td><code>matchesSelector(selector: string): Promise&lt;boolean&gt;</code></td>
<td><p translation-result="on">检查此元素是否与指定的 CSS 选择器匹配。</p><p translation-origin="off">Checks whether the element matches the given CSS selector.</p></td>
</tr>

<tr>
<td><code>setInputValue(value: string): Promise&lt;void&gt;;</code></td>
<td><p translation-result="on">设置输入属性的值。</p><p translation-origin="off">Sets the value of a property of an input.</p></td>
</tr>

<tr>
<td><code>selectOptions(...optionIndexes: number[]): Promise&lt;void&gt;;</code></td>
<td><p translation-result="on">在原生 <code>select</code> 元素中指定索引处的候选项。</p><p translation-origin="off">Selects the options at the specified indexes inside of a native <code>select</code> element.</p></td>
</tr>

<tr>
<td><code>dispatchEvent(name: string, data?: Record&lt;string, EventData&gt;): Promise&lt;void&gt;;</code></td>
<td><p translation-result="on">派发具有特定名称的事件。</p><p translation-origin="off">Dispatches an event with a particular name.</p></td>
</tr>

</tbody></table>
<p translation-result="on"><code>TestElement</code> 是一种抽象设计，适用于不同的测试环境（Karma，Protractor 等）。在使用测试工具时，你应该通过这个接口来进行所有的 DOM 交互。其他访问 DOM 元素的方法（例如 <code>document.querySelector</code> ）并不适用于所有的测试环境。</p><p translation-origin="off"><code>TestElement</code> is an abstraction designed to work across different test environments (Karma,
Protractor, etc). When using harnesses, you should perform all DOM interaction via this interface.
Other means of accessing DOM elements (e.g. <code>document.querySelector</code>) will not work in all test
environments.</p>

<p translation-result="on">最好的做法是，你不应该把 <code>TestElement</code> 实例公开给测试工具的用户，除非它是由组件消费者直接定义的元素（比如宿主元素）。公开 <code>TestElement</code> 实例会让用户依赖组件的内部 DOM 结构。</p><p translation-origin="off">As a best practice, you should not expose <code>TestElement</code> instances to users of a harness
unless its an element the component consumer defines directly (e.g. the host element). Exposing
<code>TestElement</code> instances for internal elements leads users to depend on a component's internal DOM
structure.</p>

<p translation-result="on">相反，要为最终用户可能执行的操作或可能要检查的状态提供更加专用的方法。例如，<code>MyPopupHarness</code> 可以提供像 <code>toggle</code> 和 <code>isOpen</code> 之类的方法：</p><p translation-origin="off">Instead, provide more narrow-focused methods for particular actions the end-user will
take or particular state they may want to check. For example, <code>MyPopupHarness</code> could provide methods
like <code>toggle</code> and <code>isOpen</code>:</p>

<pre><code class="language-ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPopupHarness</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ComponentHarness</span> </span>{
  <span class="hljs-keyword">static</span> hostSelector = <span class="hljs-string">'my-popup'</span>;

  <span class="hljs-keyword">protected</span> getTriggerElement = <span class="hljs-built_in">this</span>.locatorFor(<span class="hljs-string">'button'</span>);
  <span class="hljs-keyword">protected</span> getContentElement = <span class="hljs-built_in">this</span>.locatorForOptional(<span class="hljs-string">'.my-popup-content'</span>);

  <span class="hljs-comment">/** Toggles the open state of the popup. */</span>
  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">toggle</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-keyword">const</span> trigger = <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.getTriggerElement();
    <span class="hljs-keyword">return</span> trigger.click();
  }

  <span class="hljs-comment">/** Checks if the popup us open. */</span>
  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">isOpen</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-keyword">const</span> content = <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.getContentElement();
    <span class="hljs-keyword">return</span> !!content;
  }
}
</code></pre>

        <h4 id="loading-harnesses-for-subcomponents" class="docs-header-link" translation-result="on">
          <span header-link="为子组件加载测试工具"><header-link class="ng-star-inserted"><a aria-label="Link to this heading" class="docs-markdown-a" href="/cdk/test-harnesses/overview#为子组件加载测试工具" aria-describedby="为子组件加载测试工具"><mat-icon role="img" class="mat-icon notranslate material-icons mat-icon-no-color" aria-hidden="true" data-mat-icon-type="font">link</mat-icon></a></header-link></span>
          为子组件加载测试工具
        </h4><h4 class="docs-header-link" translation-origin="off">
          <span header-link="loading-harnesses-for-subcomponents"><header-link class="ng-star-inserted"><a aria-label="Link to this heading" class="docs-markdown-a" href="/cdk/test-harnesses/overview#loading-harnesses-for-subcomponents" aria-describedby="loading-harnesses-for-subcomponents"><mat-icon role="img" class="mat-icon notranslate material-icons mat-icon-no-color" aria-hidden="true" data-mat-icon-type="font">link</mat-icon></a></header-link></span>
          Loading harnesses for subcomponents
        </h4>
      
        
      <p translation-result="on">较大的组件通常是由较小的组件组合而成的。你也可以在组件测试工具中反映出这种结构。<code>ComponentHarness</code> 上的每个 <code>locatorFor</code> 族方法都有一个备用签名，可以用来定位子级测试工具而不是元素。</p><p translation-origin="off">Larger components often compose smaller components. You can reflect this structure in a
component's harness as well. Each of the <code>locatorFor</code> methods on <code>ComponentHarness</code> discussed
earlier has an alternate signature that can be used for locating sub-harnesses rather than elements.</p>

<table>
<thead>
<tr>
<th><p translation-result="on">方法</p><p translation-origin="off">Method</p></th>
<th><p translation-result="on">说明</p><p translation-origin="off">Description</p></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>locatorFor&lt;T extends ComponentHarness&gt;(harnessType: ComponentHarnessConstructor&lt;T&gt;): () =&gt; Promise&lt;T&gt;</code></td>
<td><p translation-result="on">创建一个函数，该函数在被调用时返回第一个匹配指定测试工具类型的测试工具的 <code>Promise</code>；如果找不到匹配的测试工具，<code>Promise</code> 就会拒绝。</p><p translation-origin="off">Creates a function that returns a <code>Promise</code> for the first harness matching the given harness type when called. If no matching harness is found, the <code>Promise</code> rejects.</p></td>
</tr>

<tr>
<td><code>locatorForOptional&lt;T extends ComponentHarness&gt;(harnessType: ComponentHarnessConstructor&lt;T&gt;): () =&gt; Promise&lt;T | null&gt;</code></td>
<td><p translation-result="on">创建一个函数，该函数在被调用时返回第一个匹配指定测试工具类型的测试工具的 <code>Promise</code>；如果找不到匹配的工具，就会解析成携带 <code>null</code> 的 <code>Promise</code>。</p><p translation-origin="off">Creates a function that returns a <code>Promise</code> for the first harness matching the given harness type when called. If no matching harness is found, the <code>Promise</code> is resolved with <code>null</code>.</p></td>
</tr>

<tr>
<td><code>locatorForAll&lt;T extends ComponentHarness&gt;(harnessType: ComponentHarnessConstructor&lt;T&gt;): () =&gt; Promise&lt;T[]&gt;</code></td>
<td><p translation-result="on">创建一个函数，该函数在被调用时返回一个<code>Promise</code>，携带匹配到指定测试工具类型的所有测试工具列表。</p><p translation-origin="off">Creates a function that returns a <code>Promise</code> for a list of all harnesses matching the given harness type when called.</p></td>
</tr>

</tbody></table>
<p translation-result="on">例如，考虑使用上面演示过的弹出菜单来构建菜单：</p><p translation-origin="off">For example, consider a menu build using the popup shown above:</p>

<pre><code class="language-ts"><span class="hljs-meta">@Component</span>({
  <span class="hljs-attr">selector</span>: <span class="hljs-string">'my-menu'</span>,
  <span class="hljs-attr">template</span>: <span class="hljs-string">`
    &lt;my-popup&gt;
      &lt;ng-content&gt;&lt;/ng-content&gt;
    &lt;/my-popup&gt;
  `</span>
})
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMenu</span> </span>{
  <span class="hljs-meta">@Input</span>() triggerText: <span class="hljs-built_in">string</span>;

  <span class="hljs-meta">@ContentChildren</span>(MyMenuItem) items: QueryList&lt;MyMenuItem&gt;;
}

<span class="hljs-meta">@Directive</span>({
  <span class="hljs-attr">selector</span>: <span class="hljs-string">'my-menu-item'</span>
})
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMenuItem</span> </span>{}
</code></pre>
<p translation-result="on"><code>MyMenu</code> 的测试工具就可以利用 <code>MyPopup</code> 和 <code>MyMenuItem</code> 的其他测试工具：</p><p translation-origin="off">The harness for <code>MyMenu</code> can then take advantage of other harnesses for <code>MyPopup</code> and <code>MyMenuItem</code>:</p>

<pre><code class="language-ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMenuHarness</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ComponentHarness</span> </span>{
  <span class="hljs-keyword">static</span> hostSelector = <span class="hljs-string">'my-menu'</span>;

  <span class="hljs-keyword">protected</span> getPopupHarness = <span class="hljs-built_in">this</span>.locatorFor(MyPopupHarness);

  <span class="hljs-comment">/** Gets the currently shown menu items (empty list if menu is closed). */</span>
  getItems = <span class="hljs-built_in">this</span>.locatorForAll(MyMenuItemHarness);

  <span class="hljs-comment">/** Toggles open state of the menu. */</span>
  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">toggle</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-keyword">const</span> popupHarness = <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.getPopupHarness();
    <span class="hljs-keyword">return</span> popupHarness.toggle();
  }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMenuItemHarness</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ComponentHarness</span> </span>{
  <span class="hljs-keyword">static</span> hostSelector = <span class="hljs-string">'my-menu-item'</span>;
}
</code></pre>

        <h4 id="filtering-harness-instances-with-harnesspredicate" class="docs-header-link" translation-result="on">
          <span header-link="使用-harnesspredicate-过滤测试工具实例"><header-link class="ng-star-inserted"><a aria-label="Link to this heading" class="docs-markdown-a" href="/cdk/test-harnesses/overview#使用-harnesspredicate-过滤测试工具实例" aria-describedby="使用-harnesspredicate-过滤测试工具实例"><mat-icon role="img" class="mat-icon notranslate material-icons mat-icon-no-color" aria-hidden="true" data-mat-icon-type="font">link</mat-icon></a></header-link></span>
          使用 <code>HarnessPredicate</code> 过滤测试工具实例
        </h4><h4 class="docs-header-link" translation-origin="off">
          <span header-link="filtering-harness-instances-with-harnesspredicate"><header-link class="ng-star-inserted"><a aria-label="Link to this heading" class="docs-markdown-a" href="/cdk/test-harnesses/overview#filtering-harness-instances-with-harnesspredicate" aria-describedby="filtering-harness-instances-with-harnesspredicate"><mat-icon role="img" class="mat-icon notranslate material-icons mat-icon-no-color" aria-hidden="true" data-mat-icon-type="font">link</mat-icon></a></header-link></span>
          Filtering harness instances with <code>HarnessPredicate</code>
        </h4>
      
        
      <p translation-result="on">当一个页面包含特定组件的多个实例时，你可能需要根据该组件的某些属性进行过滤，以得到一个特定的组件实例。例如，你可能想要一个带有特定文本的按钮，或一个带有特定 ID 的菜单。<code>HarnessPredicate</code> 可以为 <code>ComponentHarness</code> 的子类按一定的标准捕获它们。虽然测试作者也能手动构建 <code>HarnessPredicate</code> 实例，但 <code>ComponentHarness</code> 子类提供了一个辅助方法来为常用的过滤器构造谓词，这更容易。</p><p translation-origin="off">When a page contains multiple instances of a particular component, you may want to filter based on
some property of the component to get a particular component instance. For example, you may want
a button with some specific text, or a menu with a specific ID. The <code>HarnessPredicate</code>
class can capture criteria like this for a <code>ComponentHarness</code> subclass. While the
test author is able to construct <code>HarnessPredicate</code> instances manually, it's easier when the
<code>ComponentHarness</code> subclass provides a helper method to construct predicates for common filters.</p>

<p translation-result="on">建议在每个 <code>ComponentHarness</code> 子类的 <code>with</code> 方法中提供这个辅助方法，它返回该类的 <code>HarnessPredicate</code>。这让测试作者可以编写易于理解的代码，例如 <code>loader.getHarness(MyMenuHarness.with({selector: '#menu1'}))</code>。除了标准的 <code>selector</code> 和 <code>ancestor</code> 选项之外，<code>with</code> 方法还应该添加对特定的子类有意义的其他选项。</p><p translation-origin="off">The recommended approach to providing this helper is to create a static <code>with</code> method on each
<code>ComponentHarness</code> subclass that returns a <code>HarnessPredicate</code> for that class. This allows test
authors to write easily understandable code, e.g.
<code>loader.getHarness(MyMenuHarness.with({selector: '#menu1'}))</code>. In addition to the standard
<code>selector</code> and <code>ancestor</code> options, the <code>with</code> method should add any other options that make sense
for the particular subclass.</p>

<p translation-result="on">需要添加其他选项的测试工具应该根据需要扩展 <code>BaseHarnessFilters</code> 接口和其它可选属性。<code>HarnessPredicate</code> 为添加选项提供了一些便利方法。</p><p translation-origin="off">Harnesses that need to add additional options should extend the <code>BaseHarnessFilters</code> interface and
additional optional properties as needed. <code>HarnessPredicate</code> provides several convenience methods
for adding options.</p>

<table>
<thead>
<tr>
<th><p translation-result="on">方法</p><p translation-origin="off">Method</p></th>
<th><p translation-result="on">说明</p><p translation-origin="off">Description</p></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>static stringMatches(s: string | Promise&lt;string&gt;, pattern: string | RegExp): Promise&lt;boolean&gt;</code></td>
<td><p translation-result="on">按照 <code>string</code> 或 <code>RegExp</code> 类型的模式比较字符串或字符串的 <code>Promise</code>，并返回一个表明它是否匹配 <code>Promise</code></p><p translation-origin="off">Compares a string or <code>Promise</code> of a string against a <code>string</code> or <code>RegExp</code> and returns a boolean <code>Promise</code> indicating whether it matches.</p></td>
</tr>

<tr>
<td><code>addOption&lt;O&gt;(name: string, option: O | undefined, predicate: (harness: T, option: O) =&gt; Promise&lt;boolean&gt;): HarnessPredicate&lt;T&gt;</code></td>
<td><p translation-result="on">创建一个新的 <code>HarnessPredicate</code> 来强制执行当前的所有条件，再加上 <code>predicate</code> 参数指定的新约束条件。如果 <code>option</code> 参数为 <code>undefined</code>，此 <code>predicate</code> 总是返回 true。</p><p translation-origin="off">Creates a new <code>HarnessPredicate</code> that enforces all of the conditions of the current one, plus the new constraint specified by the <code>predicate</code> parameter. If the <code>option</code> parameter is <code>undefined</code> the <code>predicate</code> is considered to be always true.</p></td>
</tr>

<tr>
<td><code>add(description: string, predicate: (harness: T) =&gt; Promise&lt;boolean&gt;): HarnessPredicate&lt;T&gt;</code></td>
<td><p translation-result="on">创建一个新的 <code>HarnessPredicate</code> 来强制执行当前的所有条件，再加上 <code>predicate</code> 参数指定的新约束条件。</p><p translation-origin="off">Creates a new <code>HarnessPredicate</code> that enforces all of the conditions of the current one, plus the new constraint specified by the <code>predicate</code> parameter.</p></td>
</tr>

</tbody></table>
<p translation-result="on">例如，当使用菜单时，根据触发器文本添加一种过滤方式并根据文本来过滤菜单项会很有用：</p><p translation-origin="off">For example, when working with a menu it would likely be useful to add a way to filter based on
trigger text and to filter menu items based on their text:</p>

<pre><code class="language-ts"><span class="hljs-keyword">interface</span> MyMenuHarnessFilters <span class="hljs-keyword">extends</span> BaseHarnessFilters {
  <span class="hljs-comment">/** Filters based on the trigger text for the menu. */</span>
  triggerText?: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">RegExp</span>;
}

<span class="hljs-keyword">interface</span> MyMenuItemHarnessFilters <span class="hljs-keyword">extends</span> BaseHarnessFilters {
  <span class="hljs-comment">/** Filters based on the text of the menu item. */</span>
  text?: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">RegExp</span>;
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMenuHarness</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ComponentHarness</span> </span>{
  <span class="hljs-keyword">static</span> hostSelector = <span class="hljs-string">'my-menu'</span>;

  <span class="hljs-comment">/** Creates a `HarnessPredicate` used to locatr a particular `MyMenuHarness`. */</span>
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">with</span>(options: MyMenuHarnessFilters): HarnessPredicate&lt;MyMenuHarness&gt; {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HarnessPredicate(MyMenuHarness, options)
        .addOption(<span class="hljs-string">'trigger text'</span>, options.triggerText,
            <span class="hljs-function">(<span class="hljs-params">harness, text</span>) =&gt;</span> HarnessPredicate.stringMatches(harness.getTriggerText(), text));
  }

  <span class="hljs-keyword">protected</span> getPopupHarness = <span class="hljs-built_in">this</span>.locatorFor(MyPopupHarness);

  <span class="hljs-comment">/** Gets the text of the menu trigger. */</span>
  <span class="hljs-keyword">async</span> getTriggerText(): <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-built_in">string</span>&gt; {
    <span class="hljs-keyword">const</span> popupHarness = <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.getPopupHarness();
    <span class="hljs-keyword">return</span> popupHarness.getTriggerText();
  }

  ...
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMenuItemHarness</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ComponentHarness</span> </span>{
  <span class="hljs-keyword">static</span> hostSelector = <span class="hljs-string">'my-menu-item'</span>;

  <span class="hljs-comment">/** Creates a `HarnessPredicate` used to locatr a particular `MyMenuItemHarness`. */</span>
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">with</span>(options: MyMenuItemHarnessFilters): HarnessPredicate&lt;MyMenuItemHarness&gt; {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HarnessPredicate(MyMenuItemHarness, options)
        .addOption(<span class="hljs-string">'text'</span>, options.text,
            <span class="hljs-function">(<span class="hljs-params">harness, text</span>) =&gt;</span> HarnessPredicate.stringMatches(harness.getText(), text));
  }

  <span class="hljs-comment">/** Gets the text of the menu item. */</span>
  <span class="hljs-keyword">async</span> getText(): <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-built_in">string</span>&gt; {
    <span class="hljs-keyword">const</span> host = <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.host();
    <span class="hljs-keyword">return</span> host.text();
  }
}
</code></pre>
<p translation-result="on">你可以用 <code>HarnessPredicate</code> 代替 <code>ComponentHarness</code> 传给 <code>HarnessLoader</code>、<code>LocatorFactory</code> 或 <code>ComponentHarness</code> 上的任何 API。这样，测试作者就可以在创建测试工具实例时轻松定位到特定的组件实例。它还能让测试工具的作者利用同样的 <code>HarnessPredicate</code>，在他们的测试工具类上支持更强大的 API。例如前面看过的 <code>MyMenuHarness</code> 的 <code>getItems</code> 方法。现在可以很容易地扩展它以允许本测试工具的用户搜索特定的菜单项：</p><p translation-origin="off">You can pass a <code>HarnessPredicate</code> in place of a <code>ComponentHarness</code> class to any of the APIs on
<code>HarnessLoader</code>, <code>LocatorFactory</code>, or <code>ComponentHarness</code>. This allows test authors to easily target
a particular component instance when creating a harness instance. It also allows the harness author
to leverage the same <code>HarnessPredicate</code> to enable more powerful APIs on their harness class. For
example, consider the <code>getItems</code> method on the <code>MyMenuHarness</code> shown above.
This can now easily be expanded to allow users of the harness to search for particular menu items:</p>

<pre><code class="language-ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMenuHarness</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ComponentHarness</span> </span>{
  <span class="hljs-keyword">static</span> hostSelector = <span class="hljs-string">'my-menu'</span>;

  <span class="hljs-comment">/** Gets a list of items in the menu, optionally filtered based on the given criteria. */</span>
  <span class="hljs-keyword">async</span> getItems(filters: MyMenuItemHarnessFilters = {}): <span class="hljs-built_in">Promise</span>&lt;MyMenuItemHarness[]&gt; {
    <span class="hljs-keyword">const</span> getFilteredItems = <span class="hljs-built_in">this</span>.locatorForAll(MyMenuItemHarness.with(filters));
    <span class="hljs-keyword">return</span> getFilteredItems();
  }

  ...
}
</code></pre>

        <h4 id="creating-a-harnessloader-for-an-element" class="docs-header-link" translation-result="on">
          <span header-link="为元素创建一个-harnessloader"><header-link class="ng-star-inserted"><a aria-label="Link to this heading" class="docs-markdown-a" href="/cdk/test-harnesses/overview#为元素创建一个-harnessloader" aria-describedby="为元素创建一个-harnessloader"><mat-icon role="img" class="mat-icon notranslate material-icons mat-icon-no-color" aria-hidden="true" data-mat-icon-type="font">link</mat-icon></a></header-link></span>
          为元素创建一个 <code>HarnessLoader</code>
        </h4><h4 class="docs-header-link" translation-origin="off">
          <span header-link="creating-a-harnessloader-for-an-element"><header-link class="ng-star-inserted"><a aria-label="Link to this heading" class="docs-markdown-a" href="/cdk/test-harnesses/overview#creating-a-harnessloader-for-an-element" aria-describedby="creating-a-harnessloader-for-an-element"><mat-icon role="img" class="mat-icon notranslate material-icons mat-icon-no-color" aria-hidden="true" data-mat-icon-type="font">link</mat-icon></a></header-link></span>
          Creating a <code>HarnessLoader</code> for an element
        </h4>
      
        
      <p translation-result="on">有些组件会使用 <code>&lt;ng-content&gt;</code> 把其他内容投影到组件的模板中。当为这样的组件创建一个测试工具时，你可以给这个测试工具用户提供一个 <code>&lt;ng-content&gt;</code> 容器范围内的 <code>HarnessLoader</code> 实例。这可以让测试工具的用户能够为任何作为内容传进来的组件加载额外的测试工具。<code>ComponentHarness</code> 有几个 API 可以用来为这种情况创建 <code>HarnessLoader</code> 实例。</p><p translation-origin="off">Some components use <code>&lt;ng-content&gt;</code> to project additional content into the component's template. When
creating a harness for such a component, you can give the harness user a <code>HarnessLoader</code> instance
scoped to the element containing the <code>&lt;ng-content&gt;</code>. This allows the user of the harness to load
additional harnesses for whatever components were passed in as content. <code>ComponentHarness</code> has
several APIs that can be used to create <code>HarnessLoader</code> instances for cases like this.</p>

<table>
<thead>
<tr>
<th><p translation-result="on">方法</p><p translation-origin="off">Method</p></th>
<th><p translation-result="on">说明</p><p translation-origin="off">Description</p></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>harnessLoaderFor(selector: string): Promise&lt;HarnessLoader&gt;</code></td>
<td><p translation-result="on">获取一个 <code>Promise</code>，它解析为以指定的选择器相匹配的第一个元素为根的 <code>HarnessLoader</code>；如果没有找到此组件，则 <code>Promise</code> 会拒绝。</p><p translation-origin="off">Gets a <code>Promise</code> for a <code>HarnessLoader</code> rooted at the first element matching the given selector, if no element is found the <code>Promise</code> rejects.</p></td>
</tr>

<tr>
<td><code>harnessLoaderForOptional(selector: string): Promise&lt;HarnessLoader | null&gt;</code></td>
<td><p translation-result="on">获取一个 <code>Promise</code>，它解析为与指定选择器匹配的第一个元素，如果没有找到此元素，则 <code>Promise</code> 会解析为 <code>null</code>。</p><p translation-origin="off">Gets a <code>Promise</code> for a <code>HarnessLoader</code> rooted at the first element matching the given selector, if no element is found the <code>Promise</code> resolves to <code>null</code>.</p></td>
</tr>

<tr>
<td><code>harnessLoaderForAll(selector: string): Promise&lt;HarnessLoader[]&gt;</code></td>
<td><p translation-result="on">获取一个 <code>Promise</code>，它是一个以和指定选择器匹配的每个元素为根的 <code>HarnessLoader</code> 列表</p><p translation-origin="off">Gets a <code>Promise</code> for a list of <code>HarnessLoader</code>, one rooted at each element matching the given selector.</p></td>
</tr>

</tbody></table>
<p translation-result="on">前面讨论过的 <code>MyPopup</code> 组件就是一个很好的例子，它包含了一些用户可能希望为其加载测试工具的内容。
<code>MyPopupHarness</code> 可以通过扩展 <code>ContentContainerComponentHarness</code> 来为此添加支持。</p><p translation-origin="off">The <code>MyPopup</code> component discussed earlier is a good example of a component with arbitrary content
that users may want to load harnesses for. <code>MyPopupHarness</code> could add support for this by
extending <code>ContentContainerComponentHarness</code>.</p>

<pre><code class="language-ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPopupHarness</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ContentContainerComponentHarness</span>&lt;<span class="hljs-title">string</span>&gt; </span>{
  <span class="hljs-keyword">static</span> hostSelector = <span class="hljs-string">'my-popup'</span>;
}
</code></pre>

        <h4 id="accessing-elements-outside-of-the-components-host-element" class="docs-header-link" translation-result="on">
          <span header-link="访问该组件的宿主元素之外的元素"><header-link class="ng-star-inserted"><a aria-label="Link to this heading" class="docs-markdown-a" href="/cdk/test-harnesses/overview#访问该组件的宿主元素之外的元素" aria-describedby="访问该组件的宿主元素之外的元素"><mat-icon role="img" class="mat-icon notranslate material-icons mat-icon-no-color" aria-hidden="true" data-mat-icon-type="font">link</mat-icon></a></header-link></span>
          访问该组件的宿主元素之外的元素
        </h4><h4 class="docs-header-link" translation-origin="off">
          <span header-link="accessing-elements-outside-of-the-components-host-element"><header-link class="ng-star-inserted"><a aria-label="Link to this heading" class="docs-markdown-a" href="/cdk/test-harnesses/overview#accessing-elements-outside-of-the-components-host-element" aria-describedby="accessing-elements-outside-of-the-components-host-element"><mat-icon role="img" class="mat-icon notranslate material-icons mat-icon-no-color" aria-hidden="true" data-mat-icon-type="font">link</mat-icon></a></header-link></span>
          Accessing elements outside of the component's host element
        </h4>
      
        
      <p translation-result="on">有时组件工具可能需要访问相应组件的宿主元素之外的元素。那些使用 <a href="https://material.angular.cn/cdk/overlay/overview">CDK 浮层</a>的组件就是这样的例子。
组件的宿主元素外面的 CDK 浮层会创建一个直接附着在 body 上的元素。在这个例子中，<code>ComponentHarness</code> 提供了一个方法，可以用来获取根元素的 <code>LocatorFactory</code>。
此 <code>LocatorFactory</code> 支持大多数与 <code>ComponentHarness</code> 基类相同的 API，然后可以用来相对于该文档的根元素进行查询。</p><p translation-origin="off">There are times when a component harness might need to access elements outside of its corresponding
component's host element. Components that use <a href="https://material.angular.io/cdk/overlay/overview">CDK overlay</a> serve as examples of this. The CDK overlay creates an element that is attached directly to the body, outside of the component's host element. In this case,
<code>ComponentHarness</code> provides a method that can be used to get a <code>LocatorFactory</code> for the root element
of the document. The <code>LocatorFactory</code> supports most of the same APIs as the <code>ComponentHarness</code> base
class, and can then be used to query relative to the document's root element.</p>

<table>
<thead>
<tr>
<th><p translation-result="on">方法</p><p translation-origin="off">Method</p></th>
<th><p translation-result="on">说明</p><p translation-origin="off">Description</p></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>documentRootLocatorFactory(): LocatorFactory</code></td>
<td><p translation-result="on">创建一个以该文档的根元素为根的 <code>LocatorFactory</code>。</p><p translation-origin="off">Creates a <code>LocatorFactory</code> rooted at the document's root element.</p></td>
</tr>

</tbody></table>
<p translation-result="on">假设 <code>MyPopup</code> 组件使用了 CDK 浮层作为弹出内容，而不是它自己模板中的一个元素。在这种情况下，<code>MyPopupHarness</code> 可能必须通过 <code>documentRootLocatorFactory()</code> 访问其内容元素：</p><p translation-origin="off">Consider if the <code>MyPopup</code> component above used the CDK overlay for the popup content, rather than an
element in its own template. In this case, <code>MyPopupHarness</code> would have to access the content element
via <code>documentRootLocatorFactory()</code>:</p>

<pre><code class="language-ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPopupHarness</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ComponentHarness</span> </span>{
  <span class="hljs-keyword">static</span> hostSelector = <span class="hljs-string">'my-popup'</span>;

  <span class="hljs-comment">/** Gets a `HarnessLoader` whose root element is the popup's content element. */</span>
  <span class="hljs-keyword">async</span> getHarnessLoaderForContent(): <span class="hljs-built_in">Promise</span>&lt;HarnessLoader&gt; {
    <span class="hljs-keyword">const</span> rootLocator = <span class="hljs-built_in">this</span>.documentRootLocatorFactory();
    <span class="hljs-keyword">return</span> rootLocator.harnessLoaderFor(<span class="hljs-string">'my-popup-content'</span>);
  }
}
</code></pre>

        <h4 id="waiting-for-asynchronous-tasks" class="docs-header-link" translation-result="on">
          <span header-link="等待异步任务"><header-link class="ng-star-inserted"><a aria-label="Link to this heading" class="docs-markdown-a" href="/cdk/test-harnesses/overview#等待异步任务" aria-describedby="等待异步任务"><mat-icon role="img" class="mat-icon notranslate material-icons mat-icon-no-color" aria-hidden="true" data-mat-icon-type="font">link</mat-icon></a></header-link></span>
          等待异步任务
        </h4><h4 class="docs-header-link" translation-origin="off">
          <span header-link="waiting-for-asynchronous-tasks"><header-link class="ng-star-inserted"><a aria-label="Link to this heading" class="docs-markdown-a" href="/cdk/test-harnesses/overview#waiting-for-asynchronous-tasks" aria-describedby="waiting-for-asynchronous-tasks"><mat-icon role="img" class="mat-icon notranslate material-icons mat-icon-no-color" aria-hidden="true" data-mat-icon-type="font">link</mat-icon></a></header-link></span>
          Waiting for asynchronous tasks
        </h4>
      
        
      <p translation-result="on"><code>TestElement</code> 上的方法会自动触发 Angular 的变更检测，并等待 <code>NgZone</code> 中的任务，所以在大多数情况下，这些方法不需要特别的工作来让线程作者等待异步任务。
然而，在一些边缘情况下这可能还不够。</p><p translation-origin="off">The methods on <code>TestElement</code> automatically trigger Angular's change detection and wait for tasks
inside the <code>NgZone</code>, so in most cases no special effort is required for harness authors to wait on
asynchronous tasks. However, there are some edge cases where this may not be sufficient.</p>

<p translation-result="on">在某些情况下，在完全刷新动画事件之前，Angular 动画可能还需要第二个变更检测循环和等待 <code>NgZone</code> 进入稳定状态。
如果需要这样做，<code>ComponentHarness</code> 提供了一个 <code>forceStabilize()</code> 方法，可以调用它来进行第二轮测试。</p><p translation-origin="off">Under some circumstances, Angular animations may require a second cycle of change detection and
subsequent <code>NgZone</code> stabilization before animation events are fully flushed. In cases where this is
needed, the <code>ComponentHarness</code> offers a <code>forceStabilize()</code> method that can be called to do the
second round.</p>

<p translation-result="on">另外，某些组件可能会故意在 <code>NgZone</code> <em>之外</em>安排任务，这通常是使用 <code>NgZone.runOutsideAngular</code> 完成的。
在这种情况下，对应的测试工具可能需要显式等待 <code>NgZone</code> 以外的任务，因为这不会自动发生。
<code>ComponentHarness</code> 为此提供了一个名为 <code>waitForTasksOutsideAngular</code> 的方法。</p><p translation-origin="off">Additionally, some components may intentionally schedule tasks <em>outside</em> of <code>NgZone</code>, this is
typically accomplished by using <code>NgZone.runOutsideAngular</code>. In this case, the corresponding harness
may need to explicitly wait for tasks outside <code>NgZone</code>, as this does not happen automatically.
<code>ComponentHarness</code> offers a method called <code>waitForTasksOutsideAngular</code> for this purpose.</p>

<table>
<thead>
<tr>
<th><p translation-result="on">方法</p><p translation-origin="off">Method</p></th>
<th><p translation-result="on">说明</p><p translation-origin="off">Description</p></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>forceStabilize(): Promise&lt;void&gt;</code></td>
<td><p translation-result="on">在 Angular 中显式运行一轮变更检测，并等待 <code>NgZone</code> 稳定下来。</p><p translation-origin="off">Explicitly runs a round of change detection in Angular and waits for <code>NgZone</code> to stabilize.</p></td>
</tr>

<tr>
<td><code>waitForTasksOutsideAngular(): Promise&lt;void&gt;</code></td>
<td><p translation-result="on">等待 <code>NgZone</code> 以外的任务完成。</p><p translation-origin="off">Waits for tasks scheduled outside of <code>NgZone</code> to complete.</p></td>
</tr>

</tbody></table>

        <h3 id="api-for-harness-environment-authors" class="docs-header-link" translation-result="on">
          <span header-link="测试工具环境作者的-api"><header-link class="ng-star-inserted"><a aria-label="Link to this heading" class="docs-markdown-a" href="/cdk/test-harnesses/overview#测试工具环境作者的-api" aria-describedby="测试工具环境作者的-api"><mat-icon role="img" class="mat-icon notranslate material-icons mat-icon-no-color" aria-hidden="true" data-mat-icon-type="font">link</mat-icon></a></header-link></span>
          测试工具环境作者的 API
        </h3><h3 class="docs-header-link" translation-origin="off">
          <span header-link="api-for-harness-environment-authors"><header-link class="ng-star-inserted"><a aria-label="Link to this heading" class="docs-markdown-a" href="/cdk/test-harnesses/overview#api-for-harness-environment-authors" aria-describedby="api-for-harness-environment-authors"><mat-icon role="img" class="mat-icon notranslate material-icons mat-icon-no-color" aria-hidden="true" data-mat-icon-type="font">link</mat-icon></a></header-link></span>
          API for harness environment authors
        </h3>
      
        
      <p translation-result="on">测试工具环境作者是那些希望在其他测试环境中增加使用组件测试工具支持的开发人员。开箱即用的 Angular CDK 组件测试工具可用于 Protractor E2E 测试和 Karma 单元测试。开发人员可以创建 <code>TestElement</code> 和 <code>HarnessEnvironment</code> 的自定义实现来支持更多环境。</p><p translation-origin="off">Harness environment authors are developers who want to add support for using component harnesses in
additional testing environments. Out-of-the-box, Angular CDK's component harnesses can be used in
Protractor E2E tests and Karma unit tests. Developers can support additional environments by
creating custom implementations of <code>TestElement</code> and <code>HarnessEnvironment</code>.</p>


        <h4 id="creating-a-testelement-implementation-for-the-environment" class="docs-header-link" translation-result="on">
          <span header-link="为此环境创建一个-testelement"><header-link class="ng-star-inserted"><a aria-label="Link to this heading" class="docs-markdown-a" href="/cdk/test-harnesses/overview#为此环境创建一个-testelement" aria-describedby="为此环境创建一个-testelement"><mat-icon role="img" class="mat-icon notranslate material-icons mat-icon-no-color" aria-hidden="true" data-mat-icon-type="font">link</mat-icon></a></header-link></span>
          为此环境创建一个 <code>TestElement</code>
        </h4><h4 class="docs-header-link" translation-origin="off">
          <span header-link="creating-a-testelement-implementation-for-the-environment"><header-link class="ng-star-inserted"><a aria-label="Link to this heading" class="docs-markdown-a" href="/cdk/test-harnesses/overview#creating-a-testelement-implementation-for-the-environment" aria-describedby="creating-a-testelement-implementation-for-the-environment"><mat-icon role="img" class="mat-icon notranslate material-icons mat-icon-no-color" aria-hidden="true" data-mat-icon-type="font">link</mat-icon></a></header-link></span>
          Creating a <code>TestElement</code> implementation for the environment
        </h4>
      
        
      <p translation-result="on">添加对新测试环境的支持的第一步是创建一个 <code>TestElement</code> 实现。<code>TestElement</code> 接口用作 DOM 元素的环境无关表示形式。它能让测试工具与 DOM 元素进行交互，而不用管底层环境如何。由于某些环境不支持与 DOM 元素的同步交互（比如 webdriver），因此所有的 <code>TestElement</code> 方法都是异步的，返回一个包含该操作结果的 <code>Promise</code></p><p translation-origin="off">The first step in adding support for a new testing environment is to create a <code>TestElement</code>
implementation. The <code>TestElement</code> interface serves as an environment-agnostic representation of a
DOM element; it lets harnesses interact with DOM elements regardless of the underlying environment.
Because some environments don't support interacting with DOM elements synchronously
(e.g. webdriver), all of the <code>TestElement</code> methods are asynchronous, returning a <code>Promise</code> with the
result of the operation.</p>

<table>
<thead>
<tr>
<th><p translation-result="on">方法</p><p translation-origin="off">Method</p></th>
<th><p translation-result="on">说明</p><p translation-origin="off">Description</p></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>blur(): Promise&lt;void&gt;</code></td>
<td><p translation-result="on">让此元素失焦。</p><p translation-origin="off">Blurs the element.</p></td>
</tr>

<tr>
<td><code>clear(): Promise&lt;void&gt;</code></td>
<td><p translation-result="on">从此元素中清除文本（仅适用于 <code>&lt;input&gt;</code> 和 <code>&lt;textarea&gt;</code> ）。</p><p translation-origin="off">Clears the text from an element (only applies for <code>&lt;input&gt;</code> and <code>&lt;textarea&gt;</code>).</p></td>
</tr>

<tr>
<td><code>click(relativeX?: number, relativeY?: number): Promise&lt;void&gt;</code></td>
<td><p translation-result="on">在相对于它左上角的坐标点击此元素。</p><p translation-origin="off">Clicks an element at a point relative to it's top-left corner.</p></td>
</tr>

<tr>
<td><code>focus(): Promise&lt;void&gt;</code></td>
<td><p translation-result="on">让此元素获得焦点。</p><p translation-origin="off">Focuses the element.</p></td>
</tr>

<tr>
<td><code>getCssValue(property: string): Promise&lt;string&gt;</code></td>
<td><p translation-result="on">获取此元素指定属性的计算 CSS 值。</p><p translation-origin="off">Gets the computed CSS value of the given property for the element.</p></td>
</tr>

<tr>
<td><code>hover(): Promise&lt;void&gt;</code></td>
<td><p translation-result="on">将鼠标悬停在此元素上方。</p><p translation-origin="off">Hovers the mouse over the element.</p></td>
</tr>

<tr>
<td><code>sendKeys(...keys: (string | TestKey)[]): Promise&lt;void&gt;</code></td>
<td><p translation-result="on">向此元素发送一系列按键事件。</p><p translation-origin="off">Sends a sequence of key events to the element.</p></td>
</tr>

<tr>
<td><code>sendKeys(modifiers: ModifierKeys, ...keys: (string | TestKey)[]): Promise&lt;void&gt;</code></td>
<td><p translation-result="on">把一系列按键事件发送给此元素，同时按住一组修饰键。</p><p translation-origin="off">Sends a sequence of key events to the element, while holding a set of modifier keys.</p></td>
</tr>

<tr>
<td><code>text(): Promise&lt;string&gt;</code></td>
<td><p translation-result="on">获取此元素的文本内容。</p><p translation-origin="off">Gets the text content of the element.</p></td>
</tr>

<tr>
<td><code>getAttribute(name: string): Promise&lt;string | null&gt;</code></td>
<td><p translation-result="on">从此元素获取指定 HTML 属性的值。</p><p translation-origin="off">Gets the value of the given HTML attribute for the element.</p></td>
</tr>

<tr>
<td><code>hasClass(name: string): Promise&lt;boolean&gt;</code></td>
<td><p translation-result="on">检查此元素是否具有指定的类。</p><p translation-origin="off">Checks whether the element has the given class.</p></td>
</tr>

<tr>
<td><code>getDimensions(): Promise&lt;ElementDimensions&gt;</code></td>
<td><p translation-result="on">获取此元素的尺寸。</p><p translation-origin="off">Gets the dimensions of the element.</p></td>
</tr>

<tr>
<td><code>getProperty(name: string): Promise&lt;any&gt;</code></td>
<td><p translation-result="on">从此元素获取指定属性的值。</p><p translation-origin="off">Gets the value of the given property for the element.</p></td>
</tr>

<tr>
<td><code>matchesSelector(selector: string): Promise&lt;boolean&gt;</code></td>
<td><p translation-result="on">检查指定的选择器是否与此元素匹配。</p><p translation-origin="off">Checks whether the given selector matches the element.</p></td>
</tr>

<tr>
<td><code>setInputValue(value: string): Promise&lt;void&gt;;</code></td>
<td><p translation-result="on">设置输入框的值。</p><p translation-origin="off">Sets the value of a property of an input.</p></td>
</tr>

<tr>
<td><code>selectOptions(...optionIndexes: number[]): Promise&lt;void&gt;;</code></td>
<td><p translation-result="on">选择原生 <code>select</code> 元素中指定索引处的候选项。</p><p translation-origin="off">Selects the options at the specified indexes inside of a native <code>select</code> element.</p></td>
</tr>

<tr>
<td><code>dispatchEvent(name: string, data?: Record&lt;string, EventData&gt;): Promise&lt;void&gt;;</code></td>
<td><p translation-result="on">派发具有特定名称的事件。</p><p translation-origin="off">Dispatches an event with a particular name.</p></td>
</tr>

</tbody></table>
<p translation-result="on"><code>TestElement</code> 接口包含类似 <code>HTMLElement</code> 方法的大部分方法。在大多数测试环境中都存在类似的方法，这使得实现这些方法相当简单。使用 <code>sendKeys</code> 方法时要注意的一个重要区别是，<code>TestKey</code> 枚举中的键码可能与测试环境中使用的键码有所不同。环境作者应该坚持从 <code>TestKey</code> 代码映射到特定测试环境中的代码。</p><p translation-origin="off">The <code>TestElement</code> interface consists largely of methods that resemble methods
available on <code>HTMLElement</code>; similar methods exist in most test environments, which makes
implementing the methods fairly straightforward. However, one important difference to note when
implementing the <code>sendKeys</code> method, is that the key codes in the <code>TestKey</code>
enum likely differ from the key codes used in the test environment. Environment authors should
maintain a mapping from <code>TestKey</code> codes to the codes used in the particular testing environment.</p>

<p translation-result="on">Angular CDK 中的 <a href="https://github.com/angular/components/blob/master/src/cdk/testing/testbed/unit-test-element.ts#L57"><code>UnitTestElement</code></a> 和 <a href="https://github.com/angular/components/blob/master/src/cdk/testing/protractor/protractor-element.ts#L67"><code>ProtractorElement</code></a> 实现就是实现这个接口的好例子。</p><p translation-origin="off">The
<a href="https://github.com/angular/components/blob/master/src/cdk/testing/testbed/unit-test-element.ts#L57"><code>UnitTestElement</code></a>
and
<a href="https://github.com/angular/components/blob/master/src/cdk/testing/protractor/protractor-element.ts#L67"><code>ProtractorElement</code></a>
implementations in Angular CDK serve as good examples of implementations of this interface.</p>


        <h4 id="creating-a-harnessenvironemnt-implementation-for-the-environment" class="docs-header-link" translation-result="on">
          <span header-link="为此环境创建一个-harnessenvironemnt"><header-link class="ng-star-inserted"><a aria-label="Link to this heading" class="docs-markdown-a" href="/cdk/test-harnesses/overview#为此环境创建一个-harnessenvironemnt" aria-describedby="为此环境创建一个-harnessenvironemnt"><mat-icon role="img" class="mat-icon notranslate material-icons mat-icon-no-color" aria-hidden="true" data-mat-icon-type="font">link</mat-icon></a></header-link></span>
          为此环境创建一个 <code>HarnessEnvironemnt</code>
        </h4><h4 class="docs-header-link" translation-origin="off">
          <span header-link="creating-a-harnessenvironemnt-implementation-for-the-environment"><header-link class="ng-star-inserted"><a aria-label="Link to this heading" class="docs-markdown-a" href="/cdk/test-harnesses/overview#creating-a-harnessenvironemnt-implementation-for-the-environment" aria-describedby="creating-a-harnessenvironemnt-implementation-for-the-environment"><mat-icon role="img" class="mat-icon notranslate material-icons mat-icon-no-color" aria-hidden="true" data-mat-icon-type="font">link</mat-icon></a></header-link></span>
          Creating a <code>HarnessEnvironemnt</code> implementation for the environment
        </h4>
      
        
      <p translation-result="on">测试作者使用 <code>HarnessEnvironemnt</code> 来创建用于测试的组件工具实例。</p><p translation-origin="off">Test authors use <code>HarnessEnvironemnt</code> to create component harness instances for use in tests.</p>

<p translation-result="on"><code>HarnessEnvironment</code> 是一个抽象类，必须进行扩展才能为新环境创建一个具体的子类。在支持新的测试环境时，你必须创建一个 <code>HarnessEnvironment</code> 子类，为所有抽象成员添加具体的实现。</p><p translation-origin="off"><code>HarnessEnvironment</code> is an abstract class that must be extended to create a concrete subclass for
the new environment. When supporting a new test environment, you must create a <code>HarnessEnvironment</code>
subclass that adds concrete implementations for all abstract members.</p>

<p translation-result="on">你会发现 <code>HarnessEnvironment</code> 有一个泛型类型参数：<code>HarnessEnvironment&lt;E&gt;</code>。这个参数 <code>E</code> 就表示环境的原始元素类型。例如，这个参数在单元测试环境下是 <code>Element</code>。</p><p translation-origin="off">You will notice that <code>HarnessEnvironment</code> has a generic type parameter: <code>HarnessEnvironment&lt;E&gt;</code>.
This parameter, <code>E</code>, represents the raw element type of the environment. For example, this parameter
is <code>Element</code> for unit test environments.</p>

<p translation-result="on">下面是必须要实现的抽象方法：</p><p translation-origin="off">The following are the abstract methods that must be implemented:</p>

<table>
<thead>
<tr>
<th><p translation-result="on">方法</p><p translation-origin="off">Method</p></th>
<th><p translation-result="on">说明</p><p translation-origin="off">Description</p></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>abstract getDocumentRoot(): E</code></td>
<td><p translation-result="on">获取此环境的根元素（例如 <code>document.body</code> ）。</p><p translation-origin="off">Gets the root element for the environment (e.g. <code>document.body</code>).</p></td>
</tr>

<tr>
<td><code>abstract createTestElement(element: E): TestElement</code></td>
<td><p translation-result="on">为指定的原始元素创建一个 <code>TestElement</code></p><p translation-origin="off">Creates a <code>TestElement</code> for the given raw element.</p></td>
</tr>

<tr>
<td><code>abstract createEnvironment(element: E): HarnessEnvironment</code></td>
<td><p translation-result="on">根据指定的原始元素创建一个 <code>HarnessEnvironment</code></p><p translation-origin="off">Creates a <code>HarnessEnvironment</code> rooted at the given raw element.</p></td>
</tr>

<tr>
<td><code>abstract getAllRawElements(selector: string): Promise&lt;E[]&gt;</code></td>
<td><p translation-result="on">获取环境根元素下的所有与指定选择器匹配的原始元素。</p><p translation-origin="off">Gets all of the raw elements under the root element of the environment matching the given selector.</p></td>
</tr>

<tr>
<td><code>abstract forceStabilize(): Promise&lt;void&gt;</code></td>
<td><p translation-result="on">获取一个当 <code>NgZone</code> 稳定时解析的 <code>Promise</code>。另外，只要可能，就告诉 <code>NgZone</code> 变稳定（比如在 <code>fakeAsync</code> 测试中的 <code>flush()</code></p><p translation-origin="off">Gets a <code>Promise</code> that resolves when the <code>NgZone</code> is stable. Additionally, if applicable, tells <code>NgZone</code> to stabilize (e.g. calling <code>flush()</code> in a <code>fakeAsync</code> test).</p></td>
</tr>

<tr>
<td><code>abstract waitForTasksOutsideAngular(): Promise&lt;void&gt;</code></td>
<td><p translation-result="on">获取一个 <code>Promise</code>，它会在 <code>NgZone</code> 的父区域稳定时解析。</p><p translation-origin="off">Gets a <code>Promise</code> that resolves when the parent zone of <code>NgZone</code> is stable.</p></td>
</tr>

</tbody></table>
<p translation-result="on">除了实现所缺的方法之外，这个类还应该为测试作者提供一种获取 <code>ComponentHarness</code> 实例的方法。
推荐的方法是具有一个受保护的构造函数，并提供一个名为 <code>loader</code> 的静态方法来返回一个 <code>HarnessLoader</code> 的实例。这让测试作者可以编写如下代码：<code>SomeHarnessEnvironment.loader().getHarness(...)</code>。根据特定环境的需要，该类可以提供几种不同的静态方法，或者要求传递参数。（例如，<code>TestbedHarnessEnvironment</code> 的 <code>loader</code> 方法接受了一个 <code>ComponentFixture</code>，该类还提供了另外一些名为 <code>documentRootLoader</code> 和 <code>harnessForFixture</code> 静态方法）。</p><p translation-origin="off">In addition to implementing the missing methods, this class should provide a way for test authors to
get <code>ComponentHarness</code> instances. The recommended approach is to have a protected constructor and
provide a static method called <code>loader</code> that returns a <code>HarnessLoader</code> instance. This allows test
authors to write code like: <code>SomeHarnessEnvironment.loader().getHarness(...)</code>. Depending on the
needs of the particular environment, the class may provide several different static methods or
require arguments to be passed. (e.g. the <code>loader</code> method on <code>TestbedHarnessEnvironment</code> takes a
<code>ComponentFixture</code>, and the class provides additional static methods called <code>documentRootLoader</code> and
<code>harnessForFixture</code>).</p>

<p translation-result="on">Angular CDK 中的 <a href="https://github.com/angular/components/blob/master/src/cdk/testing/testbed/testbed-harness-environment.ts#L20"><code>TestbedHarnessEnvironment</code></a> 和 <a href="https://github.com/angular/components/blob/master/src/cdk/testing/protractor/protractor-harness-environment.ts#L16"><code>ProtractorHarnessEnvironment</code></a> 的实现就是很好的例子。</p><p translation-origin="off">The
<a href="https://github.com/angular/components/blob/master/src/cdk/testing/testbed/testbed-harness-environment.ts#L20"><code>TestbedHarnessEnvironment</code></a>
and
<a href="https://github.com/angular/components/blob/master/src/cdk/testing/protractor/protractor-harness-environment.ts#L16"><code>ProtractorHarnessEnvironment</code></a>
implementations in Angular CDK serve as good examples of implementations of this interface.</p>


        <h4 id="handling-auto-change-detection-status" class="docs-header-link" translation-result="on">
          <span header-link="处理自动变更检测状态"><header-link class="ng-star-inserted"><a aria-label="Link to this heading" class="docs-markdown-a" href="/cdk/test-harnesses/overview#处理自动变更检测状态" aria-describedby="处理自动变更检测状态"><mat-icon role="img" class="mat-icon notranslate material-icons mat-icon-no-color" aria-hidden="true" data-mat-icon-type="font">link</mat-icon></a></header-link></span>
          处理自动变更检测状态
        </h4><h4 class="docs-header-link" translation-origin="off">
          <span header-link="handling-auto-change-detection-status"><header-link class="ng-star-inserted"><a aria-label="Link to this heading" class="docs-markdown-a" href="/cdk/test-harnesses/overview#handling-auto-change-detection-status" aria-describedby="handling-auto-change-detection-status"><mat-icon role="img" class="mat-icon notranslate material-icons mat-icon-no-color" aria-hidden="true" data-mat-icon-type="font">link</mat-icon></a></header-link></span>
          Handling auto change detection status
        </h4>
      
        
      <p translation-result="on">为了支持 <code>manualChangeDetection</code> 和 <code>parallel</code> API，你的环境应该为自动变更检测状态安装一个处理器。</p><p translation-origin="off">In order to support the <code>manualChangeDetection</code> and <code>parallel</code> APIs, your environment should install
a handler for the auto change detection status.</p>

<p translation-result="on">当你的环境想要开始处理自动变更检测的状态时，可以调用 <code>handleAutoChangeDetectionStatus(handler)</code>。此处理器函数会要求一个 <code>AutoChangeDetectionStatus</code> 参数，其中有两个属性：</p><p translation-origin="off">When your environment wants to start handling the auto change detection status it can call
<code>handleAutoChangeDetectionStatus(handler)</code>. The handler function will receive a 
<code>AutoChangeDetectionStatus</code> which has two properties:</p>

<ul>
<li><p translation-result="on"><code>isDisabled: boolean</code> - 表示当前是否禁用了自动检测。当为 true 时，你的环境的 <code>forceStabilize</code> 方法应该什么也不做。这样，用户就可以手动触发变更检测。</p><p translation-origin="off"><code>isDisabled: boolean</code> - Indicates whether auto change detection is currently disabled. When true,
your environment's <code>forceStabilize</code> method should act as a no-op. This allows users to trigger
change detection manually instead.</p>

</li>
<li><p translation-result="on"><code>onDetectChangesNow?: () =&gt; void</code> - 如果指定了这个可选的回调函数，你的环境应立即触发变更检测，并在变更检测完成时调用该回调函数。</p><p translation-origin="off"><code>onDetectChangesNow?: () =&gt; void</code> - If this optional callback is specified, your environment
should trigger change detection immediately and call the callback when change detection finishes.</p>

</li>
</ul>
<p translation-result="on">如果你的环境要停止处理自动变更检测的状态，可以调用 <code>stopHandlingAutoChangeDetectionStatus()</code>。</p><p translation-origin="off">If your environment wants to stop handling auto change detection status it can call
<code>stopHandlingAutoChangeDetectionStatus()</code>.</p>

</div></doc-viewer><!----><table-of-contents container=".mat-drawer-content" _nghost-material-docs-c124="" class="ng-star-inserted"><div _ngcontent-material-docs-c124="" class="docs-toc-container ng-star-inserted"><div _ngcontent-material-docs-c124="" class="docs-toc-heading">概览目录</div><nav _ngcontent-material-docs-c124="" aria-label="概览目录目录"><a _ngcontent-material-docs-c124="" class="docs-level-h3 docs-link ng-star-inserted" href="/cdk/test-harnesses/overview#component-test-harnesses"> 组件测试工具 </a><a _ngcontent-material-docs-c124="" class="docs-level-h3 docs-link ng-star-inserted" href="/cdk/test-harnesses/overview#api-for-test-authors"> 给测试作者的 API </a><a _ngcontent-material-docs-c124="" class="docs-level-h4 docs-link ng-star-inserted" href="/cdk/test-harnesses/overview#working-with-componentharness-classes"> 使用 ComponentHarness 类 </a><a _ngcontent-material-docs-c124="" class="docs-level-h4 docs-link ng-star-inserted" href="/cdk/test-harnesses/overview#using-testbedharnessenvironment-and-protractorharnessenvironment"> 使用 TestbedHarnessEnvironment 和 ProtractorHarnessEnvironment </a><a _ngcontent-material-docs-c124="" class="docs-level-h4 docs-link ng-star-inserted" href="/cdk/test-harnesses/overview#creating-harnesses-with-harnessloader"> 使用 HarnessLoader 创建测试工具 </a><a _ngcontent-material-docs-c124="" class="docs-level-h4 docs-link ng-star-inserted" href="/cdk/test-harnesses/overview#change-detection"> 变更检测 </a><a _ngcontent-material-docs-c124="" class="docs-level-h4 docs-link ng-star-inserted" href="/cdk/test-harnesses/overview#working-with-asynchronous-component-harness-methods"> 使用组件测试工具的异步方法 </a><a _ngcontent-material-docs-c124="" class="docs-level-h3 docs-link ng-star-inserted" href="/cdk/test-harnesses/overview#api-for-component-harness-authors"> 组件测试工具作者的 API </a><a _ngcontent-material-docs-c124="" class="docs-level-h4 docs-link ng-star-inserted" href="/cdk/test-harnesses/overview#extending-componentharness"> 扩展 ComponentHarness </a><a _ngcontent-material-docs-c124="" class="docs-level-h4 docs-link ng-star-inserted" href="/cdk/test-harnesses/overview#finding-elements-in-the-components-dom"> 在组件的 DOM 中查找元素 </a><a _ngcontent-material-docs-c124="" class="docs-level-h4 docs-link ng-star-inserted" href="/cdk/test-harnesses/overview#working-with-testelement-instances"> 使用 TestElement 实例 </a><a _ngcontent-material-docs-c124="" class="docs-level-h4 docs-link ng-star-inserted" href="/cdk/test-harnesses/overview#loading-harnesses-for-subcomponents"> 为子组件加载测试工具 </a><a _ngcontent-material-docs-c124="" class="docs-level-h4 docs-link ng-star-inserted" href="/cdk/test-harnesses/overview#filtering-harness-instances-with-harnesspredicate"> 使用 HarnessPredicate 过滤测试工具实例 </a><a _ngcontent-material-docs-c124="" class="docs-level-h4 docs-link ng-star-inserted" href="/cdk/test-harnesses/overview#creating-a-harnessloader-for-an-element"> 为元素创建一个 HarnessLoader </a><a _ngcontent-material-docs-c124="" class="docs-level-h4 docs-link ng-star-inserted" href="/cdk/test-harnesses/overview#accessing-elements-outside-of-the-components-host-element"> 访问该组件的宿主元素之外的元素 </a><a _ngcontent-material-docs-c124="" class="docs-level-h4 docs-link ng-star-inserted" href="/cdk/test-harnesses/overview#waiting-for-asynchronous-tasks"> 等待异步任务 </a><a _ngcontent-material-docs-c124="" class="docs-level-h3 docs-link ng-star-inserted" href="/cdk/test-harnesses/overview#api-for-harness-environment-authors"> 测试工具环境作者的 API </a><a _ngcontent-material-docs-c124="" class="docs-level-h4 docs-link ng-star-inserted" href="/cdk/test-harnesses/overview#creating-a-testelement-implementation-for-the-environment"> 为此环境创建一个 TestElement </a><a _ngcontent-material-docs-c124="" class="docs-level-h4 docs-link ng-star-inserted" href="/cdk/test-harnesses/overview#creating-a-harnessenvironemnt-implementation-for-the-environment"> 为此环境创建一个 HarnessEnvironemnt </a><a _ngcontent-material-docs-c124="" class="docs-level-h4 docs-link ng-star-inserted" href="/cdk/test-harnesses/overview#handling-auto-change-detection-status"> 处理自动变更检测状态 </a><!----></nav></div><!----></table-of-contents><!----><!----><!----></component-overview><!----></div></div></app-component-viewer><!----></main><app-footer _nghost-material-docs-c112=""><footer _ngcontent-material-docs-c112="" class="docs-footer"><div _ngcontent-material-docs-c112="" class="docs-footer-list"><div _ngcontent-material-docs-c112="" class="docs-footer-logo"><div _ngcontent-material-docs-c112="" class="footer-logo"><img _ngcontent-material-docs-c112="" src="../../../assets/img/homepage/angular-white-transparent.svg" alt="Angular icon" class="docs-footer-angular-logo"><span _ngcontent-material-docs-c112="" translation-result=""><a _ngcontent-material-docs-c112="" href="https://angular.cn">学习 Angular</a></span><span _ngcontent-material-docs-c112="" translation-origin="off"><a _ngcontent-material-docs-c112="" href="https://angular.io">Learn Angular</a></span></div></div><div _ngcontent-material-docs-c112="" class="docs-footer-version"><img _ngcontent-material-docs-c112="" src="../../../assets/img/angular-material-logo.svg" alt="Angular Material icon" class="angular-material-logo"><span _ngcontent-material-docs-c112="" translation-result="" class="version">当前版本：12.0.1</span><span _ngcontent-material-docs-c112="" translation-origin="off" class="version">Current Version: 12.0.1</span></div><div _ngcontent-material-docs-c112="" class="docs-footer-copyright"><div _ngcontent-material-docs-c112=""><span _ngcontent-material-docs-c112="">Powered by Google LLC ©2010-2021.</span><a _ngcontent-material-docs-c112="" href="https://github.com/angular/components/blob/master/LICENSE">Code licensed under an MIT-style License.</a><span _ngcontent-material-docs-c112="">Documentation licensed under CC BY 4.0.</span></div></div></div></footer></app-footer></div></div></mat-sidenav-content><!----></mat-sidenav-container></app-component-sidenav><!----></material-docs-app>
<script>
  // Note this is a customised version of the GA tracking snippet
  // See the comments below for more info
  (function (i, s, o, g, r, a, m) {
    i['GoogleAnalyticsObject'] = r;
    i[r] = i[r] || function () {
      (i[r].q = i[r].q || []).push(arguments)
    }, i[r].l = 1 * new Date();
    a = s.createElement(o),
      m = s.getElementsByTagName(o)[0];
    a.async = 1;
    a.src = g;
    ~i.name.indexOf('NG_DEFER_BOOTSTRAP') || // only load library if not running e2e tests
    m.parentNode.insertBefore(a, m)
  })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');
</script>
<script>
  // This hides the address bar on mobile browsers
  // https://developers.google.com/web/fundamentals/native-hardware/fullscreen/
  window.addEventListener('load', function () {
    window.scrollTo(0, 1);
  });
</script>
<script src="assets/translator/js/hammer.min.js"></script>
<script src="assets/translator/js/web-animations.min.js"></script>
<script src="assets/translator/js/translator.js"></script>
<script src="runtime-es2015.e1ec85b3eefc82b3e26e.js" type="module"></script><script src="runtime-es5.e1ec85b3eefc82b3e26e.js" nomodule="" defer=""></script><script src="polyfills-es5.35bff51a800c7976c976.js" nomodule="" defer=""></script><script src="polyfills-es2015.22817afc647088fa8911.js" type="module"></script><script src="main-es2015.f57b1187064a60cf3006.js" type="module"></script><script src="main-es5.f57b1187064a60cf3006.js" nomodule="" defer=""></script>

<div class="cdk-live-announcer-element cdk-visually-hidden" aria-atomic="true" aria-live="polite"></div><div id="cdk-describedby-message-container" class="cdk-visually-hidden" style="visibility: hidden;"><div id="cdk-describedby-message-0" role="tooltip">选择文档版本</div><div id="cdk-describedby-message-1" role="tooltip">选择文档的主题</div></div></body></html>